use v6;
#use MONKEY_TYPING;
my %param = ();
%param<pcwidth> = 8;

my %directive = ();

my @local_pointer = ();
my @local_symbol = ();

my %memspace;
my Int $pc;
my @memspace = ({'pc' => 0.Int});

sub setup_local_pointer() {
    for 0..99 -> $index {
	@local_pointer[$index] = -1;
    }
}

sub setup_local() {
    for 0..99 -> $index {
	@local_symbol[$index] = [];
    }
    # setup_local_pointer() is called in do_pass
}

setup_local();

my %symbol = ();

my $isa = '';
my %instructions;

# Variables required for AVR

# This should be a macro!
sub make_hash(Str $isa, Str $instr) {
  # %instructions{$isa}{$instr} = hash => {}, array => "{$isa}_instr_{$instr}";
  %instructions{$isa}{$instr}<array> = "{$isa}_instr_{$instr}";
  #%instructions{$isa}{$instr}<hash> = ();
}
my @avr_instr_inh;      make_hash('avr', 'inh');
my @avr_instr_rr;       make_hash('avr', 'rr');
my @avr_instr_ww;       make_hash('avr', 'ww');
my @avr_instr_rr3;      make_hash('avr', 'rr3');
my @avr_instr_rr4;      make_hash('avr', 'rr4');
my @avr_instr_r2;       make_hash('avr', 'r2');
my @avr_instr_r;        make_hash('avr', 'r');
my @avr_instr_r_reg;    make_hash('avr', 'r_reg');
my @avr_instr_iw;       make_hash('avr', 'iw');
my @avr_instr_ir;       make_hash('avr', 'ir');
my @avr_instr_i6r;      make_hash('avr', 'i6r');
my @avr_instr_out;      make_hash('avr', 'out');
my @avr_instr_irc;      make_hash('avr', 'irc');
my @avr_instr_sreg;     make_hash('avr', 'sreg');
my @avr_instr_tbit;     make_hash('avr', 'tbit');
my @avr_instr_brb;      make_hash('avr', 'brb');
my @avr_instr_branch;   make_hash('avr', 'branch');
my @avr_instr_lbranch;  make_hash('avr', 'lbranch');
my @avr_instr_long;     make_hash('avr', 'long');
my @avr_instr_lds;      make_hash('avr', 'lds');
my @avr_instr_sts;      make_hash('avr', 'sts');
my @avr_instr_bio;      make_hash('avr', 'bio');
my @avr_instr_i4;       make_hash('avr', 'i4');
my @avr_instr_rx;       make_hash('avr', 'rx');
my @avr_instr_xr;       make_hash('avr', 'xr');
my @avr_instr_rxplus;   make_hash('avr', 'rxplus');
my @avr_instr_xrplus;   make_hash('avr', 'xrplus');
my @avr_instr_rxminus;  make_hash('avr', 'rxminus');
my @avr_instr_xrminus;  make_hash('avr', 'xrminus');
my @avr_instr_ry;       make_hash('avr', 'ry');
my @avr_instr_yr;       make_hash('avr', 'yr');
my @avr_instr_ryplus;   make_hash('avr', 'ryplus');
my @avr_instr_yrplus;   make_hash('avr', 'yrplus');
my @avr_instr_ryminus;  make_hash('avr', 'ryminus');
my @avr_instr_yrminus;  make_hash('avr', 'yrminus');
my @avr_instr_ryq;      make_hash('avr', 'ryq');
my @avr_instr_yrq;      make_hash('avr', 'yrq');
my @avr_instr_rz;       make_hash('avr', 'rz');
my @avr_instr_stzr;     make_hash('avr', 'stzr');
my @avr_instr_rzplus;   make_hash('avr', 'rzplus');
my @avr_instr_zrplus;   make_hash('avr', 'zrplus');
my @avr_instr_rzminus;  make_hash('avr', 'rzminus');
my @avr_instr_zrminus;  make_hash('avr', 'zrminus');
my @avr_instr_rzq;      make_hash('avr', 'rzq');
my @avr_instr_zrq;      make_hash('avr', 'zrq');
my @avr_instr_z;        make_hash('avr', 'z');
my @avr_instr_zr;       make_hash('avr', 'zr');
my @avr_instr_zplus;    make_hash('avr', 'zplus');
my @avr_instr_noz;      make_hash('avr', 'noz');
# say %instructions;

# basic rules for expressions

grammar Assembler {
    token identifier              { <wb> ( <[a..z A..Z _ $]> <[a..z A..Z 0..9 _ \.]>* ) <wb> }
    token localref                { (\d\d?) ( <[fb]> ) }
    proto token number            { <*> }
    token number:sym<decimal>     { '-'? <[0..9]>+ }
    token number:sym<binary>      { '0' <[bB]> <[01]>+ }
    token number:sym<octal>       { '0' <[oO]> <[0..7]>+ }
    token number:sym<hex>         { '0' <[Xx]> <[0..9 a..f A..F]>+ }
    token number:sym<hex2>        {     '$'   (<[0..9 a..f A..F]>+) }
    proto rule term               { <*> }
    rule term:sym<localref>       { <localref> }
    rule term:sym<number>         { <number> }
    rule term:sym<funcall>        { $<identifier>=(low|LOW|high|HIGH) '(' <expression> ')' }
    rule term:sym<identifier>     { <identifier> }
    rule term:sym<pexpr>          {'(' <expression> ')' }
    token addoper                 { '+' | '-' }
    token muloper                 { '*' | '/' | '%' | '<<' | '>>' }
    rule mulexpr                  { <term> [ <muloper> <term> ]* }
    rule expression               { [ <mulexpr> [ <addoper> <mulexpr> ]* ] }
    proto token string            { <*> }
    token string:sym<singlequote> { \' ( <[a..z A..Z 0..9 <ws>]>* ) \' } # FIXME
    rule stringexpression         { <string> }
    proto rule instruction        { <*> }

  rule avr_bit                      { <expression>                                                                             }
  token avr_reg                     { <[rR]> ( \d+ ) [ '+' (\d+) ]?                                                            }
  token avr_regpair                 { <[rR]> ( \d+ ) ':' <[rR]> ( \d+ )                                                        }
  rule instruction:sym<avr_rr>      { $<mnemonic>=@avr_instr_rr      <avr_reg> ',' <avr_reg> <ws>                              }
  rule instruction:sym<avr_ww1>     { $<mnemonic>=@avr_instr_ww      <avr_regpair> ',' <avr_regpair> <ws>                      }
  rule instruction:sym<avr_ww2>     { $<mnemonic>=@avr_instr_ww      <avr_reg> ',' <avr_reg> <ws>                              }
  rule instruction:sym<avr_rr3>     { $<mnemonic>=@avr_instr_rr3     <avr_reg> ',' <avr_reg> <ws>                              }
  rule instruction:sym<avr_rr4>     { $<mnemonic>=@avr_instr_rr4     <avr_reg> ',' <avr_reg> <.ws>                             }
  rule instruction:sym<avr_r2>      { $<mnemonic>=@avr_instr_r2      <avr_reg> <ws>                                            }
  rule instruction:sym<avr_r>       { $<mnemonic>=@avr_instr_r       <avr_reg> <ws>                                                }
  rule instruction:sym<avr_inh>     { $<mnemonic>=@avr_instr_inh     <ws>                                                      }
  rule instruction:sym<avr_iw>      { $<mnemonic>=@avr_instr_iw      <ws> <avr_regpair> ',' <expression> <ws>                  }
  rule instruction:sym<avr_iw2>     { $<mnemonic>=@avr_instr_iw      <ws> <avr_reg> ',' <expression> <ws>                      }
  rule instruction:sym<avr_ir>      { $<mnemonic>=@avr_instr_ir      <ws> <avr_reg> ',' <expression> <ws>                      }
  rule instruction:sym<avr_irc>     { $<mnemonic>=@avr_instr_irc     <ws> <avr_reg> ',' <expression> <ws>                      }
  rule instruction:sym<avr_sreg>    { $<mnemonic>=@avr_instr_sreg    <ws> <avr_bit> <ws>                                       }
  rule instruction:sym<avr_tbit>    { $<mnemonic>=@avr_instr_tbit    <ws> <avr_reg> ',' <avr_bit> <ws>                         }
  rule instruction:sym<avr_brb>     { $<mnemonic>=@avr_instr_brb     <ws> <avr_bit> ',' <expression> <ws>                      }
  rule instruction:sym<avr_branch>  { $<mnemonic>=@avr_instr_branch  <ws> <expression> <ws>                                    }
  rule instruction:sym<avr_lbranch> { $<mnemonic>=@avr_instr_lbranch <ws> <expression> <ws>                                    }
  rule instruction:sym<avr_long>    { $<mnemonic>=@avr_instr_long    <ws> <expression> <ws>                                    }
  rule instruction:sym<avr_lds>     { $<mnemonic>=@avr_instr_lds     <ws> <avr_reg> ',' <expression> <ws>                      }
  rule instruction:sym<avr_sts>     { $<mnemonic>=@avr_instr_sts     <ws> <expression> ',' <avr_reg> <ws>                      }
  rule instruction:sym<avr_bio>     { $<mnemonic>=@avr_instr_bio     <ws> <expression> ',' <avr_bit> <ws>                      }
  rule instruction:sym<avr_i4>      { $<mnemonic>=@avr_instr_i4      <ws> <expression> <ws>                                    }
  rule instruction:sym<avr_rx>      { $<mnemonic>=@avr_instr_rx      <ws> <avr_reg> ',' <[xX]> <!before '+'> <ws>              }
  rule instruction:sym<avr_xr>      { $<mnemonic>=@avr_instr_xr      <ws> <[xX]> ',' <avr_reg> <ws>                            }
  rule instruction:sym<avr_rxplus>  { $<mnemonic>=@avr_instr_rxplus  <ws> <avr_reg> ',' <[xX]>'+' <ws>                         }
  rule instruction:sym<avr_xrplus>  { $<mnemonic>=@avr_instr_xrplus  <ws> <[xX]>'+' ',' <avr_reg> <ws>                         }
  rule instruction:sym<avr_rxminus> { $<mnemonic>=@avr_instr_rxminus <ws> <avr_reg> ',' '-'<[xX]> <ws>                         }
  rule instruction:sym<avr_xrminus> { $<mnemonic>=@avr_instr_xrminus <ws> '-'<[xX]> ',' <avr_reg> <ws>                         }
  rule instruction:sym<avr_ry>      { $<mnemonic>=@avr_instr_ry      <ws> <avr_reg> ',' <[yY]> <!before '}'> <ws>              }
  rule instruction:sym<avr_yr>      { $<mnemonic>=@avr_instr_yr      <ws> <[yY]> ',' <avr_reg> <ws>                            }
  rule instruction:sym<avr_ryplus>  { $<mnemonic>=@avr_instr_ryplus  <ws> <avr_reg> ',' <[yY]>'+' <!before <expression> > <ws> }
  rule instruction:sym<avr_yrplus>  { $<mnemonic>=@avr_instr_yrplus  <ws> <[yY]>'+' ',' <avr_reg> <ws>                         }
  rule instruction:sym<avr_ryminus> { $<mnemonic>=@avr_instr_ryminus <ws> <avr_reg> ',' '-'<[yY]> <ws>                         }
  rule instruction:sym<avr_yrminus> { $<mnemonic>=@avr_instr_yrminus <ws> '-'<[yY]> ',' <avr_reg> <ws>                         }
  rule instruction:sym<avr_ryq>     { $<mnemonic>=@avr_instr_ryq     <ws> <avr_reg> ',' <[yY]> '+' <expression> <ws>           }
  rule instruction:sym<avr_yrq>     { $<mnemonic>=@avr_instr_yrq     <ws> <[yY]> '+' <expression> ',' <avr_reg> <ws>           }
  rule instruction:sym<avr_rz>      { $<mnemonic>=@avr_instr_rz      <ws> <avr_reg> ',' <[zZ]> <!before '+' > <ws>             }
  rule instruction:sym<avr_stzr>    { $<mnemonic>=@avr_instr_stzr    <ws> <[zZ]> ',' <avr_reg> <ws>                            }
  rule instruction:sym<avr_rzplus>  { $<mnemonic>=@avr_instr_rzplus  <ws> <avr_reg> ',' <[zZ]>'+' <ws>                         }
  rule instruction:sym<avr_zrplus>  { $<mnemonic>=@avr_instr_zrplus  <ws> <[zZ]>'+' ',' <avr_reg> <ws>                         }
  rule instruction:sym<avr_rzminus> { $<mnemonic>=@avr_instr_rzminus <ws> <avr_reg> ',' '-'<[zZ]> <ws>                         }
  rule instruction:sym<avr_zrminus> { $<mnemonic>=@avr_instr_zrminus <ws> '-'<[zZ]> ',' <avr_reg> <ws>                         }
  rule instruction:sym<avr_rzq>     { $<mnemonic>=@avr_instr_rzq     <ws> <avr_reg> ',' <[zZ]> '+' <expression> <ws>           }
  rule instruction:sym<avr_zrq>     { $<mnemonic>=@avr_instr_zrq     <ws> <[zZ]> '+' <expression> ',' <avr_reg> <ws>           }
  rule instruction:sym<avr_zr>      { $<mnemonic>=@avr_instr_zr      <ws> <[zZ]> ',' <avr_reg> <ws>                            }
  rule instruction:sym<avr_zplus>   { $<mnemonic>=@avr_instr_zplus   <ws> <avr_reg> ',' <[zZ]>'+' <ws>                         }
  rule instruction:sym<avr_noz>     { $<mnemonic>=@avr_instr_noz     <ws>                                                      }
  rule instruction:sym<avr_i6r>     { $<mnemonic>=@avr_instr_i6r     <ws> <avr_reg> ',' <expression> <ws>                      }
  rule instruction:sym<avr_out>     { $<mnemonic>=@avr_instr_out     <ws> <expression> ',' <avr_reg> <ws>                      }
}

class Assembler::Actions {
  method localref($/) {
    my $value;
    my $index = +$/[0];
    my $index2 = @local_pointer[$index];
    if ~$/[1] eq 'f' {
      ++$index2;
    }
say "In method local_ref: index is $index ($index2)";
    if $index2 < 0 {
      $value = 0; # Should be error
    } else {
      $value = @local_symbol[$index][$index2];
    }
    make $value;
  }
  method number:sym<binary>($/)   { make :2(~$/); }
  method number:sym<octal>($/)    { make :8(~$/); }
  method number:sym<hex>($/)      { make :16(~$/); }
  method number:sym<hex2>($/)     { make :16(~$/[0]); }
  method number:sym<decimal>($/)  { make :10(~$/); }
  method term:sym<identifier>($/)           {
    my $sym = ~$/<identifier>;
    my $lcsym = $sym.lc;
    if %symbol{$lcsym}.defined {
      my $val = %symbol{$sym.lc}<value>;
      make $val;
    } else {
      error_listing "*** Undefined symbol \"$sym\"";
      make 0;
    }
  }
  method term:sym<number>($/)     { make $/<number>.ast; }
  method term:sym<expression>($/) { make $/<expression>.ast; }
  method term:sym<localref>($/)   { make $/<localref>.ast; }
  method term:sym<pexpr>($/)      { make $/<expression>.ast; }
  method term:sym<funcall>($/)    {
    if $/<identifier>.lc eq 'low' {
      make ($/<expression>.ast) +& 0xff;
    }
    if $/<identifier>.lc eq 'high' {
      make (($/<expression>.ast) +> 8) +& 0xff;
    }
  }
  method expression($/) {
    my $value = $/<mulexpr>[0].ast;
    if ?$/<addoper> {
      for 0 .. (+$<addoper> - 1) -> $index {
	my $oper = ~$/<addoper>[$index];
	if $oper ~~ '+' {
	  $value += $/<mulexpr>[$index + 1].ast;
	} else {
	  $value -= $/<mulexpr>[$index + 1].ast;
	}
      }
    }
    make $value;
  }
  method mulexpr($/) {
    my $value = +$/<term>[0].ast;
    if ?$/<muloper> {
      for 0 .. (+$/<muloper> - 1) -> $index {
	my $oper = ~$/<muloper>[$index];
	if $oper ~~ '*' {
	  $value *= $/<term>[$index + 1].ast;
	} elsif $oper ~~ '/' {
	  $value /= $/<term>[$index + 1].ast;
	} elsif $oper ~~ '%' {
	  $value %= $/<term>[$index + 1].ast;
	} elsif $oper ~~ '<<' {
	  $value +<= $/<term>[$index + 1].ast;
	} elsif $oper ~~ '>>' {
	  $value +>= $/<term>[$index + 1].ast;
	} else {
	  error_listing "Illegal operator";
	}
      }
    }
    make $value;
  }
  method string:sym<singlequote>($/) { make ~$/[0]; };
  method stringexpression($/) { make ~$/<string>.ast; };
  method bit($/) {
    my $val = $/<expression>.ast;
    if 0 <= $val <= 7 {
      make $val;
    } else {
     error_listing '*** Bit number out of range';
     make 0;
    }
  }

# AVR specific methods

  method avr_reg($/) {
    my  $reg = $/[0];
    if $/[1].defined {
      my $offset = $/[1];
      $reg += $offset;
    }
    if ! (0 <= $reg <= 31) {
      error_listing '*** Registers must be in range r0 to r31';
      $reg = 0;
    }
    make $reg;
  }
  method avr_regpair($/) {
    my $r1 = $/[0];
    my $r2 = $/[1];
    error_listing ('*** Illegal register pair') unless ($r1 == $r2 + 1) && ($r1 +& 1);
    make $r2;
  }
  method instruction:sym<avr_rr>($/) {
    my $opcode = %instructions<avr><rr><hash>{~$/<mnemonic>};
    my $r1 = +$/<avr_reg>[0].ast;
    my $r2 = +$/<avr_reg>[1].ast;
    $opcode +|= ($r1 +< 4) +& 0x1f0;
    $opcode +|=  $r2       +& 0x0f;
    $opcode +|= ($r2 +< 5) +& 0x200;
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<avr_ww1>($/) {
    my $opcode = %instructions<avr><ww><hash>{~$/<mnemonic>};
    my $r1 = +$/<regpair>[0].ast;
    my $r2 = +$/<regpair>[1].ast;
    $opcode +|= ($r1 +< 3) +& 0x00f0;
    $opcode +|= ($r2 +> 1) +& 0x000f;
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<avr_ww2>($/) {
    my $opcode = %instructions<avr><ww><hash>{~$/<mnemonic>};
    my $r1 = +$/<avr_reg>[0].ast;
    my $r2 = +$/<avr_reg>[1].ast;
    $opcode +|= ($r1 +< 3) +& 0x00f0;
    $opcode +|= ($r2 +> 1) +& 0x000f;
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<avr_rr3>($/) {
    my $opcode = %instructions<avr><rr3><hash>{~$/<mnemonic>};
    my $r1 = +$/<avr_reg>[0].ast;
    my $r2 = +$/<avr_reg>[1].ast;
    if ( (16 <= $r1 < 24) && (16 <= $r2 < 24) ) {
      $opcode +|= ($r1 +< 4) +& 0x0070;
      $opcode +|=  $r2       +& 0x0007;
    } else {
      error_listing '*** Registers must be in range 16 to 23';
    }
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<avr_rr4>($/) {
    my $opcode = %instructions<avr><rr4><hash>{~$/<mnemonic>};
    my $r1 = +$/<avr_reg>[0].ast;
    my $r2 = +$/<avr_reg>[1].ast;
    if ( (16 <= $r1 < 32) && (16 <= $r2 < 32) ) {
      $opcode +|= ($r1 +< 4) +& 0x00f0;
      $opcode +|=  $r2       +& 0x000f;
    } else {
      error_listing '*** Registers must be in range 16 to 31';
    }
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<avr_r2>($/) {
    my $opcode = %instructions<avr><r2><hash>{~$/<mnemonic>};
    my $r1 = +$/<avr_reg>.ast;
    $opcode +|= ($r1 +< 4) +& 0x1f0;
    $opcode +|=  $r1       +& 0x0f;
    $opcode +|= ($r1 +< 5) +& 0x200;
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<avr_iw>($/) {
    my $opcode = %instructions<avr><iw><hash>{~$/<mnemonic>};
    my $reg = $/<regpair>.ast;
    my $val = $/<expression>.ast;
    if ($reg < 24) || ($reg +& 1) {
      error_listing('*** Register must be r25:r24, r27:r26, r29:r28 or r31:r30');
      $reg = 24;
    }
    $opcode +|= ($reg +< 1) +& 0x0030;
    $opcode +|=  $val       +& 0x000f;
    $opcode +|= ($val +< 2) +& 0x00c0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_iw2>($/) {
    my $opcode = %instructions<avr><iw><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>.ast;
    if ($reg < 24) || ($reg +& 1) {
      error_listing('*** Register must be r24, r26, r28 or r30');
      $reg = 24;
    }
    $opcode +|= ($reg +< 1) +& 0x0030;
    $opcode +|=  $val       +& 0x000f;
    $opcode +|= ($val +< 2) +& 0x00c0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_ir>($/) {
    my $opcode = %instructions<avr><ir><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>.ast;
    if $reg < 16 {
      error_listing('*** Register must be r16 - r31');
      $reg = 16;
    }
    $opcode +|= ($reg +< 4) +& 0x00f0;
    $opcode +|=  $val       +& 0x000f;
    $opcode +|= ($val +< 4) +& 0x0f00;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_i6r>($/) {
    my $opcode = %instructions<avr><i6r><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>.ast;
    if 0 <= $val <= 63 {
      $opcode +|= ($reg +< 4) +& 0x01f0;
      $opcode +|=  $val       +& 0x000f;
      $opcode +|= ($val +< 4) +& 0x0f00;
    } else {
      error_listing '*** Location must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<avr_out>($/) {
    my $opcode = %instructions<avr><out><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>.ast;
    if 0 <= $val <= 63 {
      $opcode +|= ($reg +< 4) +& 0x01f0;
      $opcode +|=  $val       +& 0x000f;
      $opcode +|= ($val +< 4) +& 0x0f00;
    } else {
      error_listing '*** Location must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<avr_irc>($/) {
    my $opcode = %instructions<avr><irc><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>.ast +^ 0xff;
    if $reg < 16 {
      error_listing('*** Register must be r16 - r31');
      $reg = 16;
    }
    $opcode +|= ($reg +< 4) +& 0x00f0;
    $opcode +|=  $val       +& 0x000f;
    $opcode +|= ($val +< 4) +& 0x0f00;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_r>($/) {
    my $opcode = %instructions<avr><r><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
# TODO -- what was this for?
#    if ! %avr_instr_r_reg & (1 +< $reg) {
#      error_listing "Invalid use of register $reg";
#    }
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_inh>($/) {
    my $opcode = %instructions<avr><inh><hash>{~$/<mnemonic>};
    make ( ($opcode,) );
  }
  method instruction:sym<avr_sreg>($/) {
    my $opcode = %instructions<avr><sreg><hash>{~$/<mnemonic>};
    my $bit = $/<avr_bit>.ast;
    $opcode +|= ($bit +< 4) +& 0x0070;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_tbit>($/) {
    my $opcode = %instructions<avr><tbit><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $bit = $/<avr_bit>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    $opcode +|=  $bit       +& 0x0007;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_brb>($/) {
    my $opcode = %instructions<avr><brb><hash>{~$/<mnemonic>};
    my $bit = $/<avr_bit>.ast;
    my $target = $/<expression>.ast;
    my $offset = $target - $pc - 1;
    error_listing "*** Branch out of range (from $pc to $target)" if $offset > 63 || $offset < -64;
    $opcode +|= ($offset +< 3) +& 0x03f0;
    $opcode +|=  $bit          +& 0x0007;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_branch>($/) {
    my $opcode = %instructions<avr><branch><hash>{~$/<mnemonic>};
    my $target = $/<expression>.ast;
    my $offset = $target - $pc - 1;
    error_listing "*** Branch out of range (from $pc to $target)" if $offset > 63 || $offset < -64;
    $opcode +|= ($offset +< 3) +& 0x03f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_lbranch>($/) {
    my $opcode = %instructions<avr><lbranch><hash>{~$/<mnemonic>};
    my $target = $/<expression>.ast;
    my $offset = $target - $pc - 1;
    error_listing "*** Branch out of range (from $pc to $target)" if $offset > 2047 || $offset < -2048;
    $opcode +|= $offset +& 0x0fff;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_long>($/) {
    my $opcode = %instructions<avr><long><hash>{~$/<mnemonic>};
    my $target = $/<expression>.ast;
    $opcode +|= ($target +> 16) +& 0x0001;
    $opcode +|= ($target +> 13) +& 0x01f0;
    make ( ($opcode,($target +& 0xffff)) );
  }
  method instruction:sym<avr_lds>($/) {
# TODO: Handle 7-bit address variant
    my $opcode = %instructions<avr><lds><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $addr = $/<expression>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,($addr +& 0xffff)) );
  }
  method instruction:sym<avr_sts>($/) {
# TODO: Handle 7-bit address variant
    my $opcode = %instructions<avr><sts><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $addr = $/<expression>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,($addr +& 0xffff)) );
  }
  method instruction:sym<avr_bio>($/) {
    my $opcode = %instructions<avr><bio><hash>{~$/<mnemonic>};
    my $bit = $/<avr_bit>.ast;
    my $reg = $/<expression>.ast;
    error_listing '*** I/O register must be in range 0 to 31' if $reg < 0 || $reg >= 32;
    $opcode +|=  $bit       +& 0x0007;
    $opcode +|= ($reg +< 3) +& 0x00f8;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_i4>($/) {
    my $opcode = %instructions<avr><i4><hash>{~$/<mnemonic>};
    my $round = $/<expression>.ast;
    error_listing '*** Round must be in range 0 to 15' if $round < 0 || $round >= 16;
    $opcode +|= ($round +< 4) +& 0x00f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_rx>($/) {
    my $opcode = %instructions<avr><rx><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_xr>($/) {
    my $opcode = %instructions<avr><xr><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_rxplus>($/) {
    my $opcode = %instructions<avr><rxplus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_xrplus>($/) {
    my $opcode = %instructions<avr><xrplus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_rxminus>($/) {
    my $opcode = %instructions<avr><rxminus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_xrminus>($/) {
    my $opcode = %instructions<avr><xrminus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_ry>($/) {
    my $opcode = %instructions<avr><ry><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_yr>($/) {
    my $opcode = %instructions<avr><yr><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_ryplus>($/) {
    my $opcode = %instructions<avr><ryplus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_yrplus>($/) {
    my $opcode = %instructions<avr><yrplus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_ryminus>($/) {
    my $opcode = %instructions<avr><ryminus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_yrminus>($/) {
    my $opcode = %instructions<avr><yrminus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_ryq>($/) {
    my $opcode = %instructions<avr><ryq><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    if 0 <= $val <= 63 {
      $opcode +|=  $val       +& 0x0007;
      $opcode +|= ($val +< 7) +& 0x0c00;
      $opcode +|= ($val +< 8) +& 0x1000;
    } else {
      error_listing '*** Offset must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<avr_yrq>($/) {
    my $opcode = %instructions<avr><yrq><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    if 0 <= $val <= 63 {
      $opcode +|=  $val       +& 0x0007;
      $opcode +|= ($val +< 7) +& 0x0c00;
      $opcode +|= ($val +< 8) +& 0x1000;
    } else {
      error_listing '*** Offset must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<avr_rz>($/) {
    my $opcode = %instructions<avr><rz><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_stzr>($/) {
    my $opcode = %instructions<avr><stzr><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_rzplus>($/) {
    my $opcode = %instructions<avr><rzplus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_zrplus>($/) {
    my $opcode = %instructions<avr><zrplus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_rzminus>($/) {
    my $opcode = %instructions<avr><rzminus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_zrminus>($/) {
    my $opcode = %instructions<avr><zrminus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_rzq>($/) {
    my $opcode = %instructions<avr><rzq><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    if 0 <= $val <= 63 {
      $opcode +|=  $val       +& 0x0007;
      $opcode +|= ($val +< 7) +& 0x0c00;
      $opcode +|= ($val +< 8) +& 0x1000;
    } else {
      error_listing '*** Offset must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<avr_zrq>($/) {
    my $opcode = %instructions<avr><zrq><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    if 0 <= $val <= 63 {
      $opcode +|=  $val       +& 0x0007;
      $opcode +|= ($val +< 7) +& 0x0c00;
      $opcode +|= ($val +< 8) +& 0x1000;
    } else {
      error_listing '*** Offset must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<avr_z>($/) {
    my $opcode = %instructions<avr><z><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_zr>($/) {
    my $opcode = %instructions<avr><zr><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_zplus>($/) {
    my $opcode = %instructions<avr><zplus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_noz>($/) {
    my $opcode = %instructions<avr><noz><hash>{~$/<mnemonic>};
    make ( ($opcode,) );
  }
}

# Input routines

my $input_line = sub { return Str; };
my $line_number = 0;

sub
include_file(Str $filename) {
  my $HANDLE = open $filename, :r;
  my $old_input_line = $input_line;
  my $old_line_number = $line_number;
  $line_number = 0;
  $input_line = sub {
    my $line = $HANDLE.get;
    if ! $line.defined {
      $input_line = $old_input_line;
      $line_number = $old_line_number;
      if $input_line.defined {
	return $input_line();
      } else {
	return Str;
      }
    }
    ++$line_number;
    return $line;
  };
}

my %macro = ();
my $current_macro_def = '';
my $ifdepth = 0;
my $truedepth = 0;
my %define = ();

sub
expand_macro(Str $label, Str $opcode, Str $rest) {
  my $old_input_line = $input_line;
  my $old_line_number = $line_number;
  $line_number = 0;
  my $macro_name = $opcode;
  my $index = 0;
  my @args = $rest.comb(/
			<?after \"> <-[\"]>+ <?before \"> # stuff in quotes
			| \w+                                # or words
			/);
  $index = 0;
  $input_line = sub {
    my $line = %macro{$macro_name}[$index++];
    if ! $line.defined {
      $input_line = $old_input_line;
      $line_number = $old_line_number;
      if $input_line.defined {
	return $input_line();
      } else {
	return Str;
      }
    }
    # interpolate the arguments
#    say "Interpolating arguments ", @args.perl, " into $line\n";
    while ($line ~~ m/\@(<digit>)/) {
      my $value = @args[$/[0]];
      $line ~~ s/\@<digit>/{$value}/;
    }
    ++$line_number;
    return $line;
  };
}

sub
parse_line(Str $line) {
  my $tline = $line;
  my Str $label = '';
  my Str $opcode = '';
  my Str $rest = '';
  if $tline ~~ /^\S/ { # we have a label
        $tline ~~ s/^(\S+)//;
       $label = ~$0;
  } else {
    #say "no label";
  }
  $tline ~~ s/^\s+//;
  if $tline ~~ /^[\w|\.]/ {
    $tline ~~ s/^(\S+)//;
    $opcode = ~$0;
  }
  $tline ~~ s/^\s+//;
  $rest = $tline;
  my $orig_rest = $rest;
  if %macro{$opcode.lc}.defined {
    format_listing(-1, '', $label, $opcode, $rest);
    expand_macro($label, $opcode.lc, $rest);
    next;
  }
  $rest ~~ s:g/ <wb>(\w+)<wb> /{
				my $word = $0;
				if %define{$word}.defined {
				  %define{$word}
				} else {
				  $word
				}
			       }/;
  return ($label, $opcode, $orig_rest, $rest);
}

sub
get_next_line {
  loop {
    if ! $input_line.defined {
      return (Str, Str, Str, Str);
    }
    my Str $line = $input_line();
    if ! $line.defined {
      return (Str, Str, Str, Str);
    }
    if $current_macro_def {
      if $line ~~ m/^<ws>\.endm<wb>/ {
	$current_macro_def = '';
      } else {
	%macro{$current_macro_def}.push($line);
      }
      simple_listing($line);
      next;
    }
    if $line ~~ m/^<ws>?[<[\#;]>.*]?$/ { # comments
      simple_listing($line);
      next;
    }
    if $line ~~ m/^<ws>\.macro<ws>(\S+)/ {
      simple_listing($line);
      $current_macro_def = ~$/[0];
      %macro{$current_macro_def} = [];
      next;
    }
    if $line ~~ m/^<ws>\.include<ws>(\S+)/ {
      simple_listing($line);
      include_file(~$/[0]);
      next;
    }
    if $line ~~ m/^<ws>  \.if <ws> / {
      if $ifdepth == $truedepth {
	# only in this case do we care about the value of the expression
	my $expr = $line;
	$expr ~~ s/^<ws> '.if' <ws>//;
	my $m = Assembler.parse($expr,
				:actions(Assembler::Actions),
				:rule(<expression>));
	if ?+$m.ast {
	  ++$truedepth;
	}
      }
      ++$ifdepth;
      next;
    }
    if $line ~~ m/^<ws>\.else<wb>/ {
      if $ifdepth == $truedepth {
	--$truedepth;
      } else {
	if $ifdepth == $truedepth + 1 {
	  ++$truedepth;
	}
      }
      next;
    }
    if $line ~~ m/^<ws>\.endif<wb>/ {
      --$ifdepth;
      if $ifdepth < $truedepth {
	$truedepth = $ifdepth;
      }
      next;
    }
    if ($truedepth == $ifdepth) {
      my ($label, $opcode, $orig_rest, $rest) = parse_line($line);
      return ($line, $label, $opcode, $orig_rest, $rest);
    }
    else {
        simple_listing $line;
    }
  }
}

# Output

my $suppress_output = 1;
my $nolist = 0;

# listing

sub simple_listing(Str $line) {
  return if $suppress_output; # some variables below don't exist on earlier passes
  return if $nolist;
  printf "%4d                 %s\n", $line_number, $line;
}

sub error_listing(Str $msg) {
  return if $suppress_output; # some variables below don't exist on earlier passes
  return if $nolist;
  printf "                    %s\n", $msg;
}

sub format_listing(Int $pc, Str $code, Str $label, Str $opcode, Str $rest) {
  return if $suppress_output; # some variables below don't exist on earlier passes
  return if $nolist;
  my $code_str = $code;
  if $code.chars > 9 {
    $code_str = substr($code, 0, 9) ~ '>';
  }
  my $pcformat = '';
  my $pc_str;
  if $pc >= 0 {
    $pcformat = ' ' x %param<pcwidth>
      - +@memspace[0]<pcwidth> ~
	'%0'
	  ~ sprintf('%d.%dx ', +@memspace[0]<pcwidth>, +@memspace[0]<pcwidth>)
	    ~ @memspace[0]<label>;
    $pc_str = (($pc < 0) ?? (' ' x (%param<pcwidth> + 2)) !! sprintf($pcformat, $pc));
  } else {
    $pc_str = ' ' x (%param<pcwidth> + 2);
  }
  printf "%4d %s %-10s %8s %8s %s\n", $line_number, $pc_str, $code_str, $label, $opcode, $rest;
}

# S1 output

my %bytes;

my $s1outaddr = -2; # don't use -1
my $s1outcount = 0;
my $s1outstring = '';
my $s1checksum = 0;
my $s1_header = '';

my Str $s1file = '';

# Code to handle S1 format output files

sub putword($addr, $word) {
  %bytes{$addr} = $word +& 0x00ff;
  %bytes{$addr+1} = ($word +> 8) +& 0x00ff;
}

sub hexbyte($byte) {
  my $nybble2 = (($byte     ) +& 0x0f) + 0x30;
  $nybble2 += 7 if $nybble2 >= 0x3a;
  my $nybble1 = (($byte +> 4) +& 0x0f) + 0x30;
  $nybble1 += 7 if $nybble1 >= 0x3a;
  my $c1 = $nybble1.chr;
  my $c2 = $nybble2.chr;
  my $string = $c1 ~ $c2;
  return $string;
}

sub put_bytes($header, $count, $string, $checksum) {
  print $header;
  print hexbyte($count);
  print $string;
  my $tchecksum = $checksum +& 0x0ff;
  print hexbyte($tchecksum);
  print "\n";
}

sub write_s1_record() {
  if ($s1outaddr >= 0) {
    $s1checksum += $s1outcount;
    put_bytes($s1_header, $s1outcount+1, $s1outstring, +^$s1checksum);
    $s1outaddr = -2;
    $s1outcount = 0;
  }
}

sub write_s1byte($addr, $byte) {
  my $value = $byte +& 0xff;
  if ($addr != ($s1outaddr + 1)) {
    write_s1_record();
  }
  if ($s1outcount == 0) {
    if ($addr < 0x10000) {
      $s1_header = 'S1';
      $s1outstring = hexbyte($addr +> 8) ~ hexbyte($addr);
      $s1checksum = ($addr +> 8) + $addr;
      $s1outcount = 2;
    } elsif ($addr < 0x1000000) {
      $s1_header = 'S2';
      $s1outstring = hexbyte($addr +> 16) ~ hexbyte($addr +> 8) ~ hexbyte($addr);
      $s1checksum = ($addr +> 16) + ($addr +> 8) + $addr;
      $s1outcount = 3;
    } else {
      $s1_header = 'S3';
      $s1outstring = hexbyte($addr +> 24) ~ hexbyte($addr +> 16) ~ hexbyte($addr +> 8) ~ hexbyte($addr);
      $s1checksum = ($addr +> 24) + ($addr +> 16) + ($addr +> 8) + $addr;
      $s1outcount = 4;
    }
  }
  $s1outstring ~= hexbyte($byte);
  $s1checksum += $byte;
  ++$s1outcount;
  $s1outaddr = $addr;
  if ($s1outcount >= 18) {
    write_s1_record();
  }
}

sub write_s1($file) {
  my $*OUT = open($file, :w);
  for sort {$^a <=> $^b}, %bytes.keys -> $addr {
    write_s1byte(+$addr, %bytes{$addr});
  }
  write_s1_record(); # flush any remaining buffer
  say "S9030000FC";
}

sub assign_symbol(Str $labelfield, $value, $pass) {
  my $label = $labelfield.lc;
  $label ~~ s/\:$//;
  if ($label ~~ /^(\d\d?)$/ ) {
    if ($pass == 1) {
      @local_symbol[$0] = [] unless @local_symbol[$0].defined;
      @local_symbol[$0].push($pc);
    }
    ++@local_pointer[$0];
  } else {
    %symbol{$label} = {} unless %symbol{$label}.defined;
    %symbol{$label}<value> = +$value;
    %symbol{$label}<memspace> = @memspace[0]<id>;
  }
}

my %constantsize = '.db' => 1,
                   '.dw' => 2,
		   '.dl' => 4;

%directive<.byte> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing($pc, '', $label, $opcode, $rest);
  assign_symbol($label, +$pc, $pass) if $label; ++$pc;
};
%directive<.word> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing($pc, '', $label, $opcode, $rest);
  assign_symbol($label, +$pc, $pass) if $label;
  $pc += 2;
};
%directive<.long> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing($pc, '', $label, $opcode, $rest);
  assign_symbol($label, +$pc, $pass) if $label;
  $pc += 4;
};
%directive<.list> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing(-1, '', $label, $opcode, $rest);
  $nolist--;
  $nolist = 0 if $nolist < 0;
};
%directive<.nolist> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing(-1, '', $label, $opcode, $rest);
  ++$nolist;
};
%directive<.device> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing(-1, '', $label, $opcode, $rest);
};
%directive<.listmac> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing(-1, '', $label, $opcode, $rest);
};
%directive<.set> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  my $m = Assembler.parse($args,
			  :actions(Assembler::Actions),
			  :rule(<identifier>));
  my $symbol = ~$m[0];
  $args ~~ s/^<-[=]>* <ws>? '=' <ws>? //;
  $m = Assembler.parse($args,
		       :actions(Assembler::Actions),
		       :rule(<expression>));
  my $value = +$m.ast;
  format_listing(-1, '', $label, $opcode, $rest);
  assign_symbol($symbol, +$m.ast, $pass);
};
%directive<.def> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  chomp $args;
  my $m = Assembler.parse($args,
			  :actions(Assembler::Actions),
			  :rule(<identifier>));
  my $symbol = ~$m[0];
  $args = $args.substr(+$m.to); # remove identifier
  $args ~~ s/ ^ <ws> \= <ws> //;
  $m = Assembler.parse($args,
		       :actions(Assembler::Actions),
		       :rule(<identifier>));
  my $value = ~$m[0];
  simple_listing ".def $symbol = $value";
  %define{$symbol} = $value;
};
%directive<.param> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  my $m = Assembler.parse($args,
			  :actions(Assembler::Actions),
			  :rule(<identifier>));
  my $param = ~$m[0];
  $args = $args.substr(+$m.to); # remove identifier
  $args ~~ s/ ^ <ws>? \= <ws>? //;
  $m = Assembler.parse($args,
		       :actions(Assembler::Actions),
		       :rule(<expression>));
  my $value = +$m.ast;
  simple_listing ".param $param = $value";
  %param{$param} = $value;
};
%directive<.equ> = %directive<.set>;
%directive<.db> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $size = %constantsize{$opcode};
  my $format = sprintf("\%\%0\%dx", $size*2);
  my $args = $rest;
  loop {
    my $m = Assembler.parse($args,
			    :actions(Assembler::Actions),
			    :rule(<expression>));
    if ?$m {
      my $value = $m.ast;
      format_listing($pc, sprintf($format, +$value), $label, $opcode, $rest);
      putword($pc*2, $value); # FIX
      if ($size == 4) {
        putword($pc*2 + 2, $value +> 16);
      }
      $pc += $size div 2;
      $args = $args.substr(+$m.to);
      $m = $args ~~ m/ ',' /;
      last unless ?$m;
      $args = $args.substr(+$m.to); 
    } else {
      error_listing '*** unknown value';
      format_listing($pc, '', $label, $opcode, $rest);
      last;
    }
  }
};
%directive<.dw> = %directive<.db>;
%directive<.dl> = %directive<.db>;
%directive<.end> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  say ".end" unless $nolist;
};
%directive<.exit> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  simple_listing ".exit";
};
%directive<.org> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  say ".org" unless $nolist;
  my $m = Assembler.parse($rest,
			  :actions(Assembler::Actions),
			  :rule(<expression>));
  $pc = +$m.ast;
};
%directive<.pushmem> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $m = Assembler.parse($rest,
			  :actions(Assembler::Actions),
			  :rule(<identifier>));
  my $arg = ~$m[0];
  if ! %memspace{$arg}.defined {
    %memspace{$arg} = {};
    %memspace{$arg}<pc> = 0.Int;
    %memspace{$arg}<id> = $arg;
  }
  @memspace.unshift(%memspace{$arg});
  $pc := @memspace[0]<pc>;
};
%directive<.popmem> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  shift @memspace;
  $pc := @memspace[0]<pc>;
};
%directive<.defmem> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  my $m = Assembler.parse($args,
			  :actions(Assembler::Actions),
			  :rule(<identifier>));
  my $symbol = ~$m[0];
  $args ~~ s/^<-[=]>* <ws>? '=' <ws>? //;
  $m = Assembler.parse($args,
		       :actions(Assembler::Actions),
		       :rule(<expression>));
  if ?$m {
    my $value = +$m.ast;
    format_listing(-1, '', $label, $opcode, $rest);
    @memspace[0]{$symbol} = $value;
  } else {
    $m = Assembler.parse($args,
  		       :actions(Assembler::Actions),
  		       :rule(<stringexpression>));
    if ?$m {
      my $value = ~$m.ast;
      format_listing -1, '', $label, $opcode, $rest;
      @memspace[0]{$symbol} = $value;
    } else {
      simple_listing 'Unrecognised value field';
      format_listing -1, '', $label, $opcode, $rest;
    }
  }
};
%directive<.dump> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  my @args = $rest.split(',');
  for @args -> $arg {
    if $arg eq 'symbols' {
      print_symbols();
    }
  }
};
%directive<.isa> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  return unless $pass == 1;
  my $args = $rest;
  my $m = Assembler.parse($args,
                          :actions(Assembler::Actions),
                          :rule(<identifier>));
  if ?$m {
    $isa = ~$m[0];
  } else {
    say "Invalid format for .isa directive";
  }
}
# .instruction inh     clt    0x94d8
%directive<.instruction> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  return unless $pass == 1;
  my $args = $rest;
  my $m = Assembler.parse($args,
			  :actions(Assembler::Actions),
			  :rule(<identifier>));
  my $instr_type = ~$m[0];
  $args ~~ s/^ <.ws>? \S+ <.ws>? //;
  $m = Assembler.parse($args,
                       :actions(Assembler::Actions),
		       :rule(<identifier>));
  my $opc = ~$m[0];
  $args ~~ s/^ <.ws>? \S+ <.ws>? //;
  $m = Assembler.parse($args,
		       :actions(Assembler::Actions),
		       :rule(<expression>));
  my $value = +$m.ast;
  #format_listing(-1, '', $label, $opcode, $rest);
#say ".instruction: $isa $instr_type $opc $value";
  %instructions{$isa}{$instr_type}<hash>{$opc} = $value;
};
%directive<.assemble> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  #say %instructions;
  for %instructions{$isa}.keys {
    my $arrayname = %instructions{$isa}{$_}<array>;
    eval "\@$arrayname = <%instructions{$isa}{$_}.keys>";
  }
}

sub assemble_instruction($label, $opcode, $orig_rest, $rest) {
  my $words = ();
  my $code = '';
  my $instruction_length = 0;
  if $opcode {
    my $m = Assembler.parse("$opcode $rest ",
			    :actions(Assembler::Actions),
			    :rule(<instruction>));
    if $m {
      $words = $m.ast;
      my $nybbles = ((@memspace[0]<width> + 3) / 4);
      my $format = '%0' ~ sprintf("%d.%dx ", $nybbles, $nybbles);
#say $words.perl;
      for ^+$words -> $index {
        $code ~= sprintf($format, $words[$index]);
	putword(($pc+$instruction_length)*2, $words[$index]);
	$instruction_length++;
      }
      $code ~~ s/ ' ' $//; # delete trailing space
    } else {
      error_listing "*** Unrecognised instruction format";
    }
  }
  format_listing($pc, $code, $label, $opcode, $orig_rest);
  $pc += $instruction_length;
}

my @files = ();

sub do_pass(Int $pass_number) {
  $suppress_output = ($pass_number == 2) ?? 0 !! 1;
  $suppress_output = 0;
  $ifdepth = 0;
  $truedepth = 0;
  $current_macro_def = '';
  setup_local_pointer();
# reset program counters
  for %memspace.keys -> $space {
    %memspace{$space}<pc> = 0;
  }
  @memspace = ({'pc' => 0.Int});
  $pc := @memspace[0]{'pc'};

# include the filenames in reverse order so the first gets opened first
# and then chains through to the second and so on
  for 0 .. +@files-1 ->$fileindex {
      include_file(@files[$fileindex]);
  }
  loop {
    my (Str $line, Str $label, Str $opcode, Str $orig_rest, Str $rest) = get_next_line();
    if ($line.defined) {
      if $opcode.defined {
        $rest = '' unless $rest.defined;
        $opcode = '' unless $opcode.defined;
        $opcode = $opcode.lc;
        if %directive{$opcode}.defined {
	  %directive{$opcode}($label, $opcode, $rest, $pass_number);
        } else {
	  assign_symbol($label, +$pc, $pass_number) if $label;
	  assemble_instruction($label, $opcode, $orig_rest, ~$rest);
        }
      } else {
        assign_symbol($label, $pc, $pass_number) if $label;
        format_listing($pc, '', $label, '', '');
      }
    } else {
      return(0);
    }
  }
}

sub print_symbols () {
  say "";
  say "Symbol Table:";
  say "=============";
  for (sort keys %symbol) -> $symbol {
    if $symbol ~~ /^_/ {
      # ignore symbols starting with _
    } else {
      my $pcformat = '';
      my $pc_str;
      my $pc = %symbol{$symbol}<value>;
      my $memspace = %symbol{$symbol}<memspace>;
      $pcformat = ' ' x %param<pcwidth>
	- +%memspace{$memspace}<pcwidth> ~
	  '%0'
	    ~ sprintf('%d.%dx ', +%memspace{$memspace}<pcwidth>, +%memspace{$memspace}<pcwidth>)
	      ~ %memspace{$memspace}<label>;
      $pc_str = sprintf($pcformat, $pc);
      say sprintf "%s %s", $pc_str, $symbol;
    }
  }
}

#######
#
# Here's where we put the machine specific stuff
#
#######

#######
#
# End of machine specific stuff
#
#######

# START HERE
for @*ARGS -> $arg {
  if $arg ~~ /^\-s/ {
    $s1file = ~$arg;
    $s1file ~~ s/^\-s//;
    next;
  }
  unshift @files, $arg; # last file specified will be first in list
}

{
  my $*OUT = open '/dev/null', :w;
  do_pass(1+0);
}

do_pass(+2);

#say "Assembly completed!!!";
print_symbols();

if $s1file {
  write_s1($s1file);
}
