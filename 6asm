#!/home/kevin/bin/perl6

use v6;
#use MONKEY_TYPING;
my %param = ();
%param<pcwidth> = 8;

my %directive = ();

my @local_pointer = ();
my @local_symbol = ();

my %memspace;
my Int $pc;
my @memspace = ({'pc' => 0.Int});

sub setup_local_pointer() {
    for 0..99 -> $index {
	@local_pointer[$index] = -1;
    }
}

sub setup_local() {
    for 0..99 -> $index {
	@local_symbol[$index] = [];
    }
    # setup_local_pointer() is called in do_pass
}

setup_local();

my %symbol = ();

# Variables required for AVR

my %avr_instr_inh = {};
my @avr_instr_inh = %avr_instr_inh.keys;

my %avr_instr_rr = {};
my @avr_instr_rr = %avr_instr_rr.keys;

my %avr_instr_ww = {};
my @avr_instr_ww = %avr_instr_ww.keys;

my %avr_instr_rr3 = {};
my @avr_instr_rr3 = %avr_instr_rr3.keys;

my %avr_instr_rr4 = {};
my @avr_instr_rr4 = %avr_instr_rr4.keys;

my %avr_instr_r2 = {};
my @avr_instr_r2 = %avr_instr_r2.keys;

my %avr_instr_r = {};
my @avr_instr_r = %avr_instr_r.keys;

my %avr_instr_r_reg = {};
my @avr_instr_r_reg = %avr_instr_r_reg.keys;

my %avr_instr_iw = {};
my @avr_instr_iw = %avr_instr_iw.keys;

my %avr_instr_ir = {};
my @avr_instr_ir = %av_instr_ir.keys;

my %avr_instr_i6r = {};
my @avr_instr_i6r = %avr_instr_i6r.keys;

my %avr_instr_out = {};
my @avr_instr_out = %avr_instr_out.keys;

my %avr_instr_irc = {};
my @avr_instr_irc = %avr_instr_irc.keys;

my %avr_instr_sreg = {};
my @avr_instr_sreg = %avr_instr_sreg.keys;

my %avr_instr_tbit = {};
my @avr_instr_tbit = %avr_instr_tbit.keys;

my %avr_instr_brb = {};
my @avr_instr_brb = %avr_instr_brb.keys;

my %avr_instr_branch = {};
my @avr_instr_branch = %avr_instr_branch.keys;

my %avr_instr_lbranch = {};
my @avr_instr_lbranch = %avr_instr_lbranch.keys;

my %avr_instr_long = {};
my @avr_instr_long = %avr_instr_long.keys;

my %avr_instr_lds = {};
my @avr_instr_lds = %avr_instr_lds.keys;

my %avr_instr_sts = {};
my @avr_instr_sts = %avr_nstr_sts.keys;

my %avr_instr_bio = {};
my @avr_instr_bio = %avr_instr_bio.keys;

my %avr_instr_i4 = {};
my @avr_instr_i4 = %avr_instr_i4.keys;

my %avr_instr_rx = {};
my @avr_instr_rx = %avr_instr_rx.keys;

my %avr_instr_xr = {};
my @avr_instr_xr = %avr_instr_xr.keys;

my %avr_instr_rxplus = {};
my @avr_instr_rxplus = %avr_instr_rxplus.keys;

my %avr_instr_xrplus = {};
my @avr_instr_xrplus = %avr_instr_xrplus.keys;

my %avr-instr_rxminus = {};
my @avr_instr_rxminus = %avr_instr_rxminus.keys;

my %avr_instr_xrminus = {};
my @avr_instr_xrminus = %avr_nstr_xrminus.keys;

my %avr_instr_ry = {};
my @avr_instr_ry = %avr_instr_ry.keys;

my %avr_instr_yr = {};
my @avr_instr_yr = %avr_instr_yr.keys;

my %avr_instr_ryplus = {};
my @avr_instr_ryplus = %avr_instr_ryplus.keys;

my %avr_instr_yrplus = {};
my @avr_instr_yrplus = %avr_instr_yrplus.keys;

my %avr_instr_ryminus = {};
my @avr_instr_ryminus = %avr_instr_ryminus.keys;

my %avr_instr_yrminus = {};
my @avr_instr_yrminus = %avr_instr_yrminus.keys;

my %avr_instr_ryq = {};
my @avr_instr_ryq = %avr_instr_ryq.keys;

my %avr_instr_yrq = {};
my @avr_instr_yrq = %avr_instr_yrq.keys;

my %avr_instr_rz = {};
my @avr_instr_rz = %avr_instr_rz.keys;

my %avr_instr_stzr = {};
my @avr_instr_stzr = %avr_instr_stzr.keys;

my %avr_instr_rzplus = {};
my @avr_instr_rzplus = %avr_instr_rzplus.keys;

my %avr_instr_zrplus = {};
my @avr_instr_zrplus = %avr_instr_zrplus.keys;

my %avr_instr_rzminus = {};
my @avr_instr_rzminus = %avr_instr_rzminus.keys;

my %avr_instr_zrminus = {};
my @avr_instr_zrminus = %avr_instr_zrminus.keys;

my %avr_instr_rzq = {};
my @avr_instr_rzq = %avr_instr_rzq.keys;

my %avr_instr_zrq = {};
my @avr_instr_zrq = %avr_instr_zrq.keys;

my %avr_instr_z = {};
my @avr_instr_z = %avr_instr_z.keys;

my %avr_instr_zr = {};
my @avr_instr_zr = %avr_instr_zr.keys;

my %avr_instr_zplus = {};
my @avr_instr_zplus = %avr_instr_zplus.keys;

my %avr_instr_noz = {};
my @avr_instr_noz = %avr_instr_noz.keys;

# basic rules for expressions

grammar Assembler {
    token identifier { <wb> ( <[a..z A..Z _ $]> <[a..z A..Z 0..9 _ \.]>* ) <wb> }
    token localref { (\d\d?) ( <[fb]> ) }
    proto token number { <*> }
    token number:sym<decimal> { '-'? <[0..9]>+ }
    token number:sym<binary>  { '0' <[bB]> <[01]>+ }
    token number:sym<octal>   { '0' <[oO]> <[0..7]>+ }
    token number:sym<hex>     { '0' <[Xx]> <[0..9 a..f A..F]>+ }
    token number:sym<hex2>    {     '$'   (<[0..9 a..f A..F]>+) }
    proto rule term { <*> }
    rule term:sym<localref>   { <localref> }
    rule term:sym<number>     { <number> }
    rule term:sym<funcall>    { $<identifier>=(low|LOW|high|HIGH) '(' <expression> ')' }
    rule term:sym<identifier> { <identifier> }
    rule term:sym<pexpr>      {'(' <expression> ')' }
    token addoper { '+' | '-' }
    token muloper { '*' | '/' | '%' | '<<' | '>>' }
    rule mulexpr { <term> [ <muloper> <term> ]* }
    rule expression { [ <mulexpr> [ <addoper> <mulexpr> ]* ] }
    proto token string { <*> }
    token string:sym<singlequote> { \' ( <[a..z A..Z 0..9 <ws>]>* ) \' } # FIXME
    rule stringexpression { <string> }
    proto rule instruction { <*> }

  rule avr_bit                      { <expression>                                                                     }
  token avr_reg                     { <[rR]> ( \d+ ) [ '+' (\d+) ]?                                                    }
  token avr_regpair                 { <[rR]> ( \d+ ) ':' <[rR]> ( \d+ )                                                }
  rule instruction:sym<avr_rr>      { $<mnemonic>=@avr_instr_rr      <avr_reg> ',' <avr_reg> <ws>                                  }
  rule instruction:sym<avr_ww1>     { $<mnemonic>=@avr_instr_ww      <avr_regpair> ',' <avr_regpair> <ws>                          }
  rule instruction:sym<avr_ww2>     { $<mnemonic>=@avr_instr_ww      <avr_reg> ',' <avr_reg> <ws>                                  }
  rule instruction:sym<rr3>     { $<mnemonic>=@instr_rr3     <reg> ',' <reg> <ws>                                  }
  rule instruction:sym<rr4>     { $<mnemonic>=@instr_rr4     <reg> ',' <reg> <ws>                                  }
  rule instruction:sym<r2>      { $<mnemonic>=@instr_r2      <reg> <ws>                                            }
  rule instruction:sym<r>       { $<mnemonic>=@instr_r       <reg> <ws>                                            }
  rule instruction:sym<inh>     { $<mnemonic>=@instr_inh     <ws>                                                  }
  rule instruction:sym<iw>      { $<mnemonic>=@instr_iw      <ws> <regpair> ',' <expression> <ws>                  }
  rule instruction:sym<iw2>     { $<mnemonic>=@instr_iw      <ws> <reg> ',' <expression> <ws>                      }
  rule instruction:sym<ir>      { $<mnemonic>=@instr_ir      <ws> <reg> ',' <expression> <ws>                      }
  rule instruction:sym<irc>     { $<mnemonic>=@instr_irc     <ws> <reg> ',' <expression> <ws>                      }
  rule instruction:sym<sreg>    { $<mnemonic>=@instr_sreg    <ws> <bit> <ws>                                       }
  rule instruction:sym<tbit>    { $<mnemonic>=@instr_tbit    <ws> <reg> ',' <bit> <ws>                             }
  rule instruction:sym<brb>     { $<mnemonic>=@instr_brb     <ws> <bit> ',' <expression> <ws>                      }
  rule instruction:sym<branch>  { $<mnemonic>=@instr_branch  <ws> <expression> <ws>                                }
  rule instruction:sym<lbranch> { $<mnemonic>=@instr_lbranch <ws> <expression> <ws>                                }
  rule instruction:sym<long>    { $<mnemonic>=@instr_long    <ws> <expression> <ws>                                }
  rule instruction:sym<lds>     { $<mnemonic>=@instr_lds     <ws> <reg> ',' <expression> <ws>                      }
  rule instruction:sym<sts>     { $<mnemonic>=@instr_sts     <ws> <expression> ',' <reg> <ws>                      }
  rule instruction:sym<bio>     { $<mnemonic>=@instr_bio     <ws> <expression> ',' <bit> <ws>                      }
  rule instruction:sym<i4>      { $<mnemonic>=@instr_i4      <ws> <expression> <ws>                                }
  rule instruction:sym<rx>      { $<mnemonic>=@instr_rx      <ws> <reg> ',' <[xX]> <!before '+'> <ws>              }
  rule instruction:sym<xr>      { $<mnemonic>=@instr_xr      <ws> <[xX]> ',' <reg> <ws>                            }
  rule instruction:sym<rxplus>  { $<mnemonic>=@instr_rxplus  <ws> <reg> ',' <[xX]>'+' <ws>                         }
  rule instruction:sym<xrplus>  { $<mnemonic>=@instr_xrplus  <ws> <[xX]>'+' ',' <reg> <ws>                         }
  rule instruction:sym<rxminus> { $<mnemonic>=@instr_rxminus <ws> <reg> ',' '-'<[xX]> <ws>                         }
  rule instruction:sym<xrminus> { $<mnemonic>=@instr_xrminus <ws> '-'<[xX]> ',' <reg> <ws>                         }
  rule instruction:sym<ry>      { $<mnemonic>=@instr_ry      <ws> <reg> ',' <[yY]> <!before '}'> <ws>              }
  rule instruction:sym<yr>      { $<mnemonic>=@instr_yr      <ws> <[yY]> ',' <reg> <ws>                            }
  rule instruction:sym<ryplus>  { $<mnemonic>=@instr_ryplus  <ws> <reg> ',' <[yY]>'+' <!before <expression> > <ws> }
  rule instruction:sym<yrplus>  { $<mnemonic>=@instr_yrplus  <ws> <[yY]>'+' ',' <reg> <ws>                         }
  rule instruction:sym<ryminus> { $<mnemonic>=@instr_ryminus <ws> <reg> ',' '-'<[yY]> <ws>                         }
  rule instruction:sym<yrminus> { $<mnemonic>=@instr_yrminus <ws> '-'<[yY]> ',' <reg> <ws>                         }
  rule instruction:sym<ryq>     { $<mnemonic>=@instr_ryq     <ws> <reg> ',' <[yY]> '+' <expression> <ws>           }
  rule instruction:sym<yrq>     { $<mnemonic>=@instr_yrq     <ws> <[yY]> '+' <expression> ',' <reg> <ws>           }
  rule instruction:sym<rz>      { $<mnemonic>=@instr_rz      <ws> <reg> ',' <[zZ]> <!before '+' > <ws>             }
  rule instruction:sym<stzr>    { $<mnemonic>=@instr_stzr    <ws> <[zZ]> ',' <reg> <ws>                            }
  rule instruction:sym<rzplus>  { $<mnemonic>=@instr_rzplus  <ws> <reg> ',' <[zZ]>'+' <ws>                         }
  rule instruction:sym<zrplus>  { $<mnemonic>=@instr_zrplus  <ws> <[zZ]>'+' ',' <reg> <ws>                         }
  rule instruction:sym<rzminus> { $<mnemonic>=@instr_rzminus <ws> <reg> ',' '-'<[zZ]> <ws>                         }
  rule instruction:sym<zrminus> { $<mnemonic>=@instr_zrminus <ws> '-'<[zZ]> ',' <reg> <ws>                         }
  rule instruction:sym<rzq>     { $<mnemonic>=@instr_rzq     <ws> <reg> ',' <[zZ]> '+' <expression> <ws>           }
  rule instruction:sym<zrq>     { $<mnemonic>=@instr_zrq     <ws> <[zZ]> '+' <expression> ',' <reg> <ws>           }
  rule instruction:sym<zr>      { $<mnemonic>=@instr_zr      <ws> <[zZ]> ',' <reg> <ws>                            }
  rule instruction:sym<zplus>   { $<mnemonic>=@instr_zplus   <ws> <reg> ',' <[zZ]>'+' <ws>                         }
  rule instruction:sym<noz>     { $<mnemonic>=@instr_noz     <ws>                                                  }
  rule instruction:sym<i6r>     { $<mnemonic>=@instr_i6r     <ws> <reg> ',' <expression> <ws>                      }
  rule instruction:sym<out>     { $<mnemonic>=@instr_out     <ws> <expression> ',' <reg> <ws>                      }
}

augment class Assembler::Actions {
}
}

class Assembler::Actions {
  method localref($/) {
    my $value;
    if ~$/[1] eq 'f' {
      $value = @local_symbol[+$/[0]+1];
    } else {
      $value = @local_symbol[+$/[0]];
    }
    make $value;
  }
  method number:sym<binary>($/)   { make :2(~$/); }
  method number:sym<octal>($/)    { make :8(~$/); }
  method number:sym<hex>($/)      { make :16(~$/); }
  method number:sym<hex2>($/)     { make :16(~$/[0]); }
  method number:sym<decimal>($/)  { make :10(~$/); }
  method term:sym<identifier>($/)           {
    my $sym = ~$/<identifier>;
    my $lcsym = $sym.lc;
    if %symbol{$lcsym}.defined {
      my $val = %symbol{$sym.lc}<value>;
      make $val;
    } else {
      error_listing "*** Undefined symbol \"$sym\"";
      make 0;
    }
  }
  method term:sym<number>($/)     { make $/<number>.ast; }
  method term:sym<expression>($/) { make $/<expression>.ast; }
  method term:sym<localref>($/)   { make $/<localref>.ast; }
  method term:sym<pexpr>($/)      { make $/<expression>.ast; }
  method term:sym<funcall>($/)    {
    if $/<identifier>.lc eq 'low' {
      make ($/<expression>.ast) +& 0xff;
    }
    if $/<identifier>.lc eq 'high' {
      make (($/<expression>.ast) +> 8) +& 0xff;
    }
  }
  method expression($/) {
    my $value = $/<mulexpr>[0].ast;
    if ?$/<addoper> {
      for 0 .. (+$<addoper> - 1) -> $index {
	my $oper = ~$/<addoper>[$index];
	if $oper ~~ '+' {
	  $value += $/<mulexpr>[$index + 1].ast;
	} else {
	  $value -= $/<mulexpr>[$index + 1].ast;
	}
      }
    }
    make $value;
  }
  method mulexpr($/) {
    my $value = +$/<term>[0].ast;
    if ?$/<muloper> {
      for 0 .. (+$/<muloper> - 1) -> $index {
	my $oper = ~$/<muloper>[$index];
	if $oper ~~ '*' {
	  $value *= $/<term>[$index + 1].ast;
	} elsif $oper ~~ '/' {
	  $value /= $/<term>[$index + 1].ast;
	} elsif $oper ~~ '%' {
	  $value %= $/<term>[$index + 1].ast;
	} elsif $oper ~~ '<<' {
	  $value +<= $/<term>[$index + 1].ast;
	} elsif $oper ~~ '>>' {
	  $value +>= $/<term>[$index + 1].ast;
	} else {
	  error_listing "Illegal operator";
	}
      }
    }
    make $value;
  }
  method string:sym<singlequote>($/) { make ~$/[0]; };
  method stringexpression($/) { make ~$/<string>.ast; };
  method bit($/) {
    my $val = $/<expression>.ast;
    if 0 <= $val <= 7 {
      make $val;
    } else {
     error_listing '*** Bit number out of range';
     make 0;
    }
  }

# AVR specific methods

  method reg($/) {
    my  $reg = $/[0];
    if $/[1].defined {
      my $offset = $/[1];
      $reg += $offset;
    }
    if ! (0 <= $reg <= 31) {
      error_listing '*** Registers must be in range r0 to r31';
      $reg = 0;
    }
    make $reg;
  }
  method regpair($/) {
    my $r1 = $/[0];
    my $r2 = $/[1];
    error_listing ('*** Illegal register pair') unless ($r1 == $r2 + 1) && ($r1 +& 1);
    make $r2;
  }
  method instruction:sym<rr>($/) {
    my $opcode = %instr_rr{~$/<mnemonic>};
    my $r1 = +$/<reg>[0].ast;
    my $r2 = +$/<reg>[1].ast;
    $opcode +|= ($r1 +< 4) +& 0x1f0;
    $opcode +|=  $r2       +& 0x0f;
    $opcode +|= ($r2 +< 5) +& 0x200;
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<ww1>($/) {
    my $opcode = %instr_ww{~$/<mnemonic>};
    my $r1 = +$/<regpair>[0].ast;
    my $r2 = +$/<regpair>[1].ast;
    $opcode +|= ($r1 +< 3) +& 0x00f0;
    $opcode +|= ($r2 +> 1) +& 0x000f;
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<ww2>($/) {
    my $opcode = %instr_ww{~$/<mnemonic>};
    my $r1 = +$/<reg>[0].ast;
    my $r2 = +$/<reg>[1].ast;
    $opcode +|= ($r1 +< 3) +& 0x00f0;
    $opcode +|= ($r2 +> 1) +& 0x000f;
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<rr3>($/) {
    my $opcode = %instr_rr3{~$/<mnemonic>};
    my $r1 = +$/<reg>[0].ast;
    my $r2 = +$/<reg>[1].ast;
    if ( (16 <= $r1 < 24) && (16 <= $r2 < 24) ) {
      $opcode +|= ($r1 +< 4) +& 0x0070;
      $opcode +|=  $r2       +& 0x0007;
    } else {
      error_listing '*** Registers must be in range 16 to 23';
    }
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<rr4>($/) {
    my $opcode = %instr_rr4{~$/<mnemonic>};
    my $r1 = +$/<reg>[0].ast;
    my $r2 = +$/<reg>[1].ast;
    if ( (16 <= $r1 < 32) && (16 <= $r2 < 32) ) {
      $opcode +|= ($r1 +< 4) +& 0x00f0;
      $opcode +|=  $r2       +& 0x000f;
    } else {
      error_listing '*** Registers must be in range 16 to 31';
    }
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<r2>($/) {
    my $opcode = %instr_r2{~$/<mnemonic>};
    my $r1 = +$/<reg>.ast;
    $opcode +|= ($r1 +< 4) +& 0x1f0;
    $opcode +|=  $r1       +& 0x0f;
    $opcode +|= ($r1 +< 5) +& 0x200;
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<iw>($/) {
    my $opcode = %instr_iw{~$/<mnemonic>};
    my $reg = $/<regpair>.ast;
    my $val = $/<expression>.ast;
    if ($reg < 24) || ($reg +& 1) {
      error_listing('*** Register must be r25:r24, r27:r26, r29:r28 or r31:r30');
      $reg = 24;
    }
    $opcode +|= ($reg +< 1) +& 0x0030;
    $opcode +|=  $val       +& 0x000f;
    $opcode +|= ($val +< 2) +& 0x00c0;
    make ( ($opcode,) );
  }
  method instruction:sym<iw2>($/) {
    my $opcode = %instr_iw{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    my $val = $/<expression>.ast;
    if ($reg < 24) || ($reg +& 1) {
      error_listing('*** Register must be r24, r26, r28 or r30');
      $reg = 24;
    }
    $opcode +|= ($reg +< 1) +& 0x0030;
    $opcode +|=  $val       +& 0x000f;
    $opcode +|= ($val +< 2) +& 0x00c0;
    make ( ($opcode,) );
  }
  method instruction:sym<ir>($/) {
    my $opcode = %instr_ir{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    my $val = $/<expression>.ast;
    if $reg < 16 {
      error_listing('*** Register must be r16 - r31');
      $reg = 16;
    }
    $opcode +|= ($reg +< 4) +& 0x00f0;
    $opcode +|=  $val       +& 0x000f;
    $opcode +|= ($val +< 4) +& 0x0f00;
    make ( ($opcode,) );
  }
  method instruction:sym<i6r>($/) {
    my $opcode = %instr_i6r{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    my $val = $/<expression>.ast;
    if 0 <= $val <= 63 {
      $opcode +|= ($reg +< 4) +& 0x01f0;
      $opcode +|=  $val       +& 0x000f;
      $opcode +|= ($val +< 4) +& 0x0f00;
    } else {
      error_listing '*** Location must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<out>($/) {
    my $opcode = %instr_out{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    my $val = $/<expression>.ast;
    if 0 <= $val <= 63 {
      $opcode +|= ($reg +< 4) +& 0x01f0;
      $opcode +|=  $val       +& 0x000f;
      $opcode +|= ($val +< 4) +& 0x0f00;
    } else {
      error_listing '*** Location must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<irc>($/) {
    my $opcode = %instr_irc{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    my $val = $/<expression>.ast +^ 0xff;
    if $reg < 16 {
      error_listing('*** Register must be r16 - r31');
      $reg = 16;
    }
    $opcode +|= ($reg +< 4) +& 0x00f0;
    $opcode +|=  $val       +& 0x000f;
    $opcode +|= ($val +< 4) +& 0x0f00;
    make ( ($opcode,) );
  }
  method instruction:sym<r>($/) {
    my $opcode = %instr_r{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    if ! %instr_r_reg & (1 +< $reg) {
      error_listing "Invaild use of register $reg";
    }
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<inh>($/) {
    my $opcode = %instr_inh{$/<mnemonic>};
    make ( ($opcode,) );
  }
  method instruction:sym<sreg>($/) {
    my $opcode = %instr_sreg{~$/<mnemonic>};
    my $bit = $/<bit>.ast;
    $opcode +|= ($bit +< 4) +& 0x0070;
    make ( ($opcode,) );
  }
  method instruction:sym<tbit>($/) {
    my $opcode = %instr_tbit{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    my $bit = $/<bit>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    $opcode +|=  $bit       +& 0x0007;
    make ( ($opcode,) );
  }
  method instruction:sym<brb>($/) {
    my $opcode = %instr_brb{~$/<mnemonic>};
    my $bit = $/<bit>.ast;
    my $target = $/<expression>.ast;
    my $offset = $target - $pc - 1;
    error_listing "*** Branch out of range (from $pc to $target)" if $offset > 63 || $offset < -64;
    $opcode +|= ($offset +< 3) +& 0x03f0;
    $opcode +|=  $bit          +& 0x0007;
    make ( ($opcode,) );
  }
  method instruction:sym<branch>($/) {
    my $opcode = %instr_branch{~$/<mnemonic>};
    my $target = $/<expression>.ast;
    my $offset = $target - $pc - 1;
    error_listing "*** Branch out of range (from $pc to $target)" if $offset > 63 || $offset < -64;
    $opcode +|= ($offset +< 3) +& 0x03f0;
    make ( ($opcode,) );
  }
  method instruction:sym<lbranch>($/) {
    my $opcode = %instr_lbranch{~$/<mnemonic>};
    my $target = $/<expression>.ast;
    my $offset = $target - $pc - 1;
    error_listing "*** Branch out of range (from $pc to $target)" if $offset > 2047 || $offset < -2048;
    $opcode +|= $offset +& 0x0fff;
    make ( ($opcode,) );
  }
  method instruction:sym<long>($/) {
    my $opcode = %instr_long{~$/<mnemonic>};
    my $target = $/<expression>.ast;
    $opcode +|= ($target +> 16) +& 0x0001;
    $opcode +|= ($target +> 13) +& 0x01f0;
    make ( ($opcode,($target +& 0xffff)) );
  }
  method instruction:sym<lds>($/) {
# TODO: Handle 7-bit address variant
    my $opcode = %instr_lds{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    my $addr = $/<expression>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,($addr +& 0xffff)) );
  }
  method instruction:sym<sts>($/) {
# TODO: Handle 7-bit address variant
    my $opcode = %instr_sts{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    my $addr = $/<expression>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,($addr +& 0xffff)) );
  }
  method instruction:sym<bio>($/) {
    my $opcode = %instr_bio{~$/<mnemonic>};
    my $bit = $/<bit>.ast;
    my $reg = $/<expression>.ast;
    error_listing '*** I/O register must be in range 0 to 31' if $reg < 0 || $reg >= 32;
    $opcode +|=  $bit       +& 0x0007;
    $opcode +|= ($reg +< 3) +& 0x00f8;
    make ( ($opcode,) );
  }
  method instruction:sym<i4>($/) {
    my $opcode = %instr_i4{~$/<mnemonic>};
    my $round = $/<expression>.ast;
    error_listing '*** Round must be in range 0 to 15' if $round < 0 || $round >= 16;
    $opcode +|= ($round +< 4) +& 0x00f0;
    make ( ($opcode,) );
  }
  method instruction:sym<rx>($/) {
    my $opcode = %instr_rx{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<xr>($/) {
    my $opcode = %instr_xr{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<rxplus>($/) {
    my $opcode = %instr_rxplus{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<xrplus>($/) {
    my $opcode = %instr_xrplus{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<rxminus>($/) {
    my $opcode = %instr_rxminus{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<xrminus>($/) {
    my $opcode = %instr_xrminus{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<ry>($/) {
    my $opcode = %instr_ry{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<yr>($/) {
    my $opcode = %instr_yr{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<ryplus>($/) {
    my $opcode = %instr_ryplus{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<yrplus>($/) {
    my $opcode = %instr_yrplus{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<ryminus>($/) {
    my $opcode = %instr_ryminus{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<yrminus>($/) {
    my $opcode = %instr_yrminus{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<ryq>($/) {
    my $opcode = %instr_ryq{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    my $val = $/<expression>;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    if 0 <= $val <= 63 {
      $opcode +|=  $val       +& 0x0007;
      $opcode +|= ($val +< 7) +& 0x0c00;
      $opcode +|= ($val +< 8) +& 0x1000;
    } else {
      error_listing '*** Offset must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<yrq>($/) {
    my $opcode = %instr_yrq{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    my $val = $/<expression>;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    if 0 <= $val <= 63 {
      $opcode +|=  $val       +& 0x0007;
      $opcode +|= ($val +< 7) +& 0x0c00;
      $opcode +|= ($val +< 8) +& 0x1000;
    } else {
      error_listing '*** Offset must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<rz>($/) {
    my $opcode = %instr_rz{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<stzr>($/) {
    my $opcode = %instr_stzr{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<rzplus>($/) {
    my $opcode = %instr_rzplus{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<zrplus>($/) {
    my $opcode = %instr_zrplus{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<rzminus>($/) {
    my $opcode = %instr_rzminus{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<zrminus>($/) {
    my $opcode = %instr_zrminus{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<rzq>($/) {
    my $opcode = %instr_rzq{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    my $val = $/<expression>;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    if 0 <= $val <= 63 {
      $opcode +|=  $val       +& 0x0007;
      $opcode +|= ($val +< 7) +& 0x0c00;
      $opcode +|= ($val +< 8) +& 0x1000;
    } else {
      error_listing '*** Offset must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<zrq>($/) {
    my $opcode = %instr_zrq{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    my $val = $/<expression>;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    if 0 <= $val <= 63 {
      $opcode +|=  $val       +& 0x0007;
      $opcode +|= ($val +< 7) +& 0x0c00;
      $opcode +|= ($val +< 8) +& 0x1000;
    } else {
      error_listing '*** Offset must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<z>($/) {
    my $opcode = %instr_z{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<zr>($/) {
    my $opcode = %instr_zr{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<zplus>($/) {
    my $opcode = %instr_z{~$/<mnemonic>};
    my $reg = $/<reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<noz>($/) {
    my $opcode = %instr_z{~$/<mnemonic>};
    make ( ($opcode,) );
  }
}

# Input routines

my $input_line = sub { return Str; };
my $line_number = 0;

sub
include_file(Str $filename) {
  my $HANDLE = open $filename, :r;
  my $old_input_line = $input_line;
  my $old_line_number = $line_number;
  $line_number = 0;
  $input_line = sub {
    my $line = $HANDLE.get;
    if ! $line.defined {
      $input_line = $old_input_line;
      $line_number = $old_line_number;
      if $input_line.defined {
	return $input_line();
      } else {
	return Str;
      }
    }
    ++$line_number;
    return $line;
  };
}

my %macro = ();
my $current_macro_def = '';
my $ifdepth = 0;
my $truedepth = 0;
my %define = ();

sub
expand_macro(Str $label, Str $opcode, Str $rest) {
  my $old_input_line = $input_line;
  my $old_line_number = $line_number;
  $line_number = 0;
  my $macro_name = $opcode;
  my $index = 0;
  my @args = $rest.comb(/
			<?after \"> <-[\"]>+ <?before \"> # stuff in quotes
			| \w+                                # or words
			/);
  $index = 0;
  $input_line = sub {
    my $line = %macro{$macro_name}[$index++];
    if ! $line.defined {
      $input_line = $old_input_line;
      $line_number = $old_line_number;
      if $input_line.defined {
	return $input_line();
      } else {
	return Str;
      }
    }
    # interpolate the arguments
#    say "Interpolating arguments ", @args.perl, " into $line\n";
    while ($line ~~ m/\@(<digit>)/) {
      my $value = @args[$/[0]];
      $line ~~ s/\@<digit>/{$value}/;
    }
    ++$line_number;
    return $line;
  };
}

sub
parse_line(Str $line) {
  my $tline = $line;
  my Str $label = '';
  my Str $opcode = '';
  my Str $rest = '';
  if $tline ~~ /^\S/ { # we have a label
        $tline ~~ s/^(\S+)//;
       $label = ~$0;
  } else {
    #say "no label";
  }
  $tline ~~ s/^\s+//;
  if $tline ~~ /^[\w|\.]/ {
    $tline ~~ s/^(\S+)//;
    $opcode = ~$0;
  }
  $tline ~~ s/^\s+//;
  $rest = $tline;
  my $orig_rest = $rest;
  if %macro{$opcode.lc}.defined {
    format_listing(-1, '', $label, $opcode, $rest);
    expand_macro($label, $opcode.lc, $rest);
    next;
  }
  $rest ~~ s:g/ <wb>(\w+)<wb> /{
				my $word = $0;
				if %define{$word}.defined {
				  %define{$word}
				} else {
				  $word
				}
			       }/;
  return ($label, $opcode, $orig_rest, $rest);
}

sub
get_next_line {
  loop {
    if ! $input_line.defined {
      return (Str, Str, Str, Str);
    }
    my Str $line = $input_line();
    if ! $line.defined {
      return (Str, Str, Str, Str);
    }
    if $current_macro_def {
      if $line ~~ m/^<ws>\.endm<wb>/ {
	$current_macro_def = '';
      } else {
	%macro{$current_macro_def}.push($line);
      }
      simple_listing($line);
      next;
    }
    if $line ~~ m/^<ws>?[<[\#;]>.*]?$/ { # comments
      simple_listing($line);
      next;
    }
    if $line ~~ m/^<ws>\.macro<ws>(\S+)/ {
      simple_listing($line);
      $current_macro_def = ~$/[0];
      %macro{$current_macro_def} = [];
      next;
    }
    if $line ~~ m/^<ws>\.include<ws>(\S+)/ {
      simple_listing($line);
      include_file(~$/[0]);
      next;
    }
    if $line ~~ m/^<ws>  \.if <ws> / {
      if $ifdepth == $truedepth {
	# only in this case do we care about the value of the expression
	my $expr = $line;
	$expr ~~ s/^<ws> '.if' <ws>//;
	my $m = Assembler.parse($expr,
				:actions(Assembler::Actions),
				:rule(<expression>));
	if ?+$m.ast {
	  ++$truedepth;
	}
      }
      ++$ifdepth;
      next;
    }
    if $line ~~ m/^<ws>\.else<wb>/ {
      if $ifdepth == $truedepth {
	--$truedepth;
      } else {
	if $ifdepth == $truedepth + 1 {
	  ++$truedepth;
	}
      }
      next;
    }
    if $line ~~ m/^<ws>\.endif<wb>/ {
      --$ifdepth;
      if $ifdepth < $truedepth {
	$truedepth = $ifdepth;
      }
      next;
    }
    if ($truedepth == $ifdepth) {
      my ($label, $opcode, $orig_rest, $rest) = parse_line($line);
      return ($line, $label, $opcode, $orig_rest, $rest);
    }
    else {
        simple_listing $line;
    }
  }
}

# Output

my $suppress_output = 1;
my $nolist = 0;

# listing

sub simple_listing(Str $line) {
  return if $suppress_output; # some variables below don't exist on earlier passes
  return if $nolist;
  printf "%4d                 %s\n", $line_number, $line;
}

sub error_listing(Str $msg) {
  return if $suppress_output; # some variables below don't exist on earlier passes
  return if $nolist;
  printf "                    %s\n", $msg;
}

sub format_listing(Int $pc, Str $code, Str $label, Str $opcode, Str $rest) {
  return if $suppress_output; # some variables below don't exist on earlier passes
  return if $nolist;
  my $code_str = $code;
  if $code.chars > 9 {
    $code_str = substr($code, 0, 9) ~ '>';
  }
  my $pcformat = '';
  my $pc_str;
  if $pc >= 0 {
    $pcformat = ' ' x %param<pcwidth>
      - +@memspace[0]<pcwidth> ~
	'%0'
	  ~ sprintf('%d.%dx ', +@memspace[0]<pcwidth>, +@memspace[0]<pcwidth>)
	    ~ @memspace[0]<label>;
    $pc_str = (($pc < 0) ?? (' ' x (%param<pcwidth> + 2)) !! sprintf($pcformat, $pc));
  } else {
    $pc_str = ' ' x (%param<pcwidth> + 2);
  }
  printf "%4d %s %-10s %8s %8s %s\n", $line_number, $pc_str, $code_str, $label, $opcode, $rest;
}

# S1 output

my %bytes;

my $s1outaddr = -2; # don't use -1
my $s1outcount = 0;
my $s1outstring = '';
my $s1checksum = 0;
my $s1_header = '';

my Str $s1file = '';

# Code to handle S1 format output files

sub putword($addr, $word) {
  %bytes{$addr} = $word +& 0x00ff;
  %bytes{$addr+1} = ($word +> 8) +& 0x00ff;
}

sub hexbyte($byte) {
  my $nybble2 = (($byte     ) +& 0x0f) + 0x30;
  $nybble2 += 7 if $nybble2 >= 0x3a;
  my $nybble1 = (($byte +> 4) +& 0x0f) + 0x30;
  $nybble1 += 7 if $nybble1 >= 0x3a;
  my $c1 = $nybble1.chr;
  my $c2 = $nybble2.chr;
  my $string = $c1 ~ $c2;
  return $string;
}

sub put_bytes($header, $count, $string, $checksum) {
  print $header;
  print hexbyte($count);
  print $string;
  my $tchecksum = $checksum +& 0x0ff;
  print hexbyte($tchecksum);
  print "\n";
}

sub write_s1_record() {
  if ($s1outaddr >= 0) {
    $s1checksum += $s1outcount;
    put_bytes($s1_header, $s1outcount+1, $s1outstring, +^$s1checksum);
    $s1outaddr = -2;
    $s1outcount = 0;
  }
}

sub write_s1byte($addr, $byte) {
  my $value = $byte +& 0xff;
  if ($addr != ($s1outaddr + 1)) {
    write_s1_record();
  }
  if ($s1outcount == 0) {
    if ($addr < 0x10000) {
      $s1_header = 'S1';
      $s1outstring = hexbyte($addr +> 8) ~ hexbyte($addr);
      $s1checksum = ($addr +> 8) + $addr;
      $s1outcount = 2;
    } elsif ($addr < 0x1000000) {
      $s1_header = 'S2';
      $s1outstring = hexbyte($addr +> 16) ~ hexbyte($addr +> 8) ~ hexbyte($addr);
      $s1checksum = ($addr +> 16) + ($addr +> 8) + $addr;
      $s1outcount = 3;
    } else {
      $s1_header = 'S3';
      $s1outstring = hexbyte($addr +> 24) ~ hexbyte($addr +> 16) ~ hexbyte($addr +> 8) ~ hexbyte($addr);
      $s1checksum = ($addr +> 24) + ($addr +> 16) + ($addr +> 8) + $addr;
      $s1outcount = 4;
    }
  }
  $s1outstring ~= hexbyte($byte);
  $s1checksum += $byte;
  ++$s1outcount;
  $s1outaddr = $addr;
  if ($s1outcount >= 18) {
    write_s1_record();
  }
}

sub write_s1($file) {
  my $*OUT = open($file, :w);
  for sort {$^a <=> $^b}, %bytes.keys -> $addr {
    write_s1byte(+$addr, %bytes{$addr});
  }
  write_s1_record(); # flush any remaining buffer
  say "S9030000FC";
}

sub assign_symbol(Str $labelfield, $value, $pass) {
  my $label = $labelfield.lc;
  $label ~~ s/\:$//;
  if ($label ~~ /^(\d\d?)$/ ) {
    if ($pass == 1) {
      @local_symbol[$0] = [] unless @local_symbol[$0].defined;
      @local_symbol[$0].push($pc);
    }
    ++@local_pointer[$0];
  } else {
    %symbol{$label} = {} unless %symbol{$label}.defined;
    %symbol{$label}<value> = +$value;
    %symbol{$label}<memspace> = @memspace[0]<id>;
  }
}

my %constantsize = '.db' => 1,
                   '.dw' => 2,
		   '.dl' => 4;

%directive<.byte> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing($pc, '', $label, $opcode, $rest);
  assign_symbol($label, +$pc, $pass) if $label; ++$pc;
};
%directive<.word> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing($pc, '', $label, $opcode, $rest);
  assign_symbol($label, +$pc, $pass) if $label;
  $pc += 2;
};
%directive<.long> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing($pc, '', $label, $opcode, $rest);
  assign_symbol($label, +$pc, $pass) if $label;
  $pc += 4;
};
%directive<.list> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing(-1, '', $label, $opcode, $rest);
  $nolist--;
  $nolist = 0 if $nolist < 0;
};
%directive<.nolist> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing(-1, '', $label, $opcode, $rest);
  ++$nolist;
};
%directive<.device> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing(-1, '', $label, $opcode, $rest);
};
%directive<.listmac> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing(-1, '', $label, $opcode, $rest);
};
%directive<.set> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  my $m = Assembler.parse($args,
			  :actions(Assembler::Actions),
			  :rule(<identifier>));
  my $symbol = ~$m[0];
  $args ~~ s/^<-[=]>* <ws>? '=' <ws>? //;
  $m = Assembler.parse($args,
		       :actions(Assembler::Actions),
		       :rule(<expression>));
  my $value = +$m.ast;
  format_listing(-1, '', $label, $opcode, $rest);
  assign_symbol($symbol, +$m.ast, $pass);
};
%directive<.def> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  chomp $args;
  my $m = Assembler.parse($args,
			  :actions(Assembler::Actions),
			  :rule(<identifier>));
  my $symbol = ~$m[0];
  $args = $args.substr(+$m.to); # remove identifier
  $args ~~ s/ ^ <ws> \= <ws> //;
  $m = Assembler.parse($args,
		       :actions(Assembler::Actions),
		       :rule(<identifier>));
  my $value = ~$m[0];
  simple_listing ".def $symbol = $value";
  %define{$symbol} = $value;
};
%directive<.param> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  my $m = Assembler.parse($args,
			  :actions(Assembler::Actions),
			  :rule(<identifier>));
  my $param = ~$m[0];
  $args = $args.substr(+$m.to); # remove identifier
  $args ~~ s/ ^ <ws>? \= <ws>? //;
  $m = Assembler.parse($args,
		       :actions(Assembler::Actions),
		       :rule(<expression>));
  my $value = +$m.ast;
  simple_listing ".param $param = $value";
  %param{$param} = $value;
};
%directive<.equ> = %directive<.set>;
%directive<.db> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $size = %constantsize{$opcode};
  my $format = sprintf("\%\%0\%dx", $size*2);
  my $args = $rest;
  loop {
    my $m = Assembler.parse($args,
			    :actions(Assembler::Actions),
			    :rule(<expression>));
    if ?$m {
      my $value = $m.ast;
      format_listing($pc, sprintf($format, +$value), $label, $opcode, $rest);
      putword($pc*2, $value); # FIX
      if ($size == 4) {
        putword($pc*2 + 2, $value +> 16);
      }
      $pc += $size div 2;
      $args = $args.substr(+$m.to);
      $m = $args ~~ m/ ',' /;
      last unless ?$m;
      $args = $args.substr(+$m.to); 
    } else {
      error_listing '*** unknown value';
      format_listing($pc, '', $label, $opcode, $rest);
      last;
    }
  }
};
%directive<.dw> = %directive<.db>;
%directive<.dl> = %directive<.db>;
%directive<.end> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  say ".end" unless $nolist;
};
%directive<.exit> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  simple_listing ".exit";
};
%directive<.org> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  say ".org" unless $nolist;
  my $m = Assembler.parse($rest,
			  :actions(Assembler::Actions),
			  :rule(<expression>));
  $pc = +$m.ast;
};
%directive<.pushmem> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $m = Assembler.parse($rest,
			  :actions(Assembler::Actions),
			  :rule(<identifier>));
  my $arg = ~$m[0];
  if ! %memspace{$arg}.defined {
    %memspace{$arg} = {};
    %memspace{$arg}<pc> = 0.Int;
    %memspace{$arg}<id> = $arg;
  }
  @memspace.unshift(%memspace{$arg});
  $pc := @memspace[0]<pc>;
};
%directive<.popmem> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  shift @memspace;
  $pc := @memspace[0]<pc>;
};
%directive<.defmem> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  my $m = Assembler.parse($args,
			  :actions(Assembler::Actions),
			  :rule(<identifier>));
  my $symbol = ~$m[0];
  $args ~~ s/^<-[=]>* <ws>? '=' <ws>? //;
  $m = Assembler.parse($args,
		       :actions(Assembler::Actions),
		       :rule(<expression>));
  if ?$m {
    my $value = +$m.ast;
    format_listing(-1, '', $label, $opcode, $rest);
    @memspace[0]{$symbol} = $value;
  } else {
    $m = Assembler.parse($args,
  		       :actions(Assembler::Actions),
  		       :rule(<stringexpression>));
    if ?$m {
      my $value = ~$m.ast;
      format_listing -1, '', $label, $opcode, $rest;
      @memspace[0]{$symbol} = $value;
    } else {
      simple_listing 'Unrecognised value field';
      format_listing -1, '', $label, $opcode, $rest;
    }
  }
};
%directive<.dump> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  my @args = $rest.split(',');
  for @args -> $arg {
    if $arg eq 'symbols' {
      print_symbols();
    }
  }
};

sub assemble_instruction($label, $opcode, $orig_rest, $rest) {
  my $words = ();
  my $code = '';
  my $instruction_length = 0;
  if $opcode {
    my $m = Assembler.parse("$opcode $rest ",
			    :actions(Assembler::Actions),
			    :rule(<instruction>));
    if $m {
      $words = $m.ast;
      my $nybbles = ((@memspace[0]<width> + 3) / 4);
      my $format = '%0' ~ sprintf("%d.%dx ", $nybbles, $nybbles);
      for 0 .. (+$words - 1) -> $index {
        $code ~= sprintf($format, $words[$index]);
	putword(($pc+$instruction_length)*2, $words[$index]);
	$instruction_length++;
      }
      $code ~~ s/ ' ' $//; # delete trailing space
    } else {
      error_listing "*** Unrecognised instruction format";
    }
  }
  format_listing($pc, $code, $label, $opcode, $orig_rest);
  $pc += $instruction_length;
}

my @files = ();

sub do_pass(Int $pass_number) {
  $suppress_output = ($pass_number == 2) ?? 0 !! 1;
  $suppress_output = 0;
  $ifdepth = 0;
  $truedepth = 0;
  $current_macro_def = '';
  setup_local_pointer();
# reset program counters
  for %memspace.keys -> $space {
    %memspace{$space}<pc> = 0;
  }
  @memspace = ({'pc' => 0.Int});
  $pc := @memspace[0]{'pc'};

# include the filenames in reverse order so the first gets opened first
# and then chains through to the second and so on
  for 0 .. +@files-1 ->$fileindex {
      include_file(@files[$fileindex]);
  }
  loop {
    my (Str $line, Str $label, Str $opcode, Str $orig_rest, Str $rest) = get_next_line();
    if ($line.defined) {
      if $opcode.defined {
        $rest = '' unless $rest.defined;
        $opcode = '' unless $opcode.defined;
        $opcode = $opcode.lc;
        if %directive{$opcode}.defined {
	  %directive{$opcode}($label, $opcode, $rest, $pass_number);
        } else {
	  assign_symbol($label, +$pc, $pass_number) if $label;
	  assemble_instruction($label, $opcode, $orig_rest, ~$rest);
        }
      } else {
        assign_symbol($label, $pc, $pass_number) if $label;
        format_listing($pc, '', $label, '', '');
      }
    } else {
      return(0);
    }
  }
}

sub print_symbols () {
  say "";
  say "Symbol Table:";
  say "=============";
  for (sort keys %symbol) -> $symbol {
    if $symbol ~~ /^_/ {
      # ignore symbols starting with _
    } else {
      my $pcformat = '';
      my $pc_str;
      my $pc = %symbol{$symbol}<value>;
      my $memspace = %symbol{$symbol}<memspace>;
      $pcformat = ' ' x %param<pcwidth>
	- +%memspace{$memspace}<pcwidth> ~
	  '%0'
	    ~ sprintf('%d.%dx ', +%memspace{$memspace}<pcwidth>, +%memspace{$memspace}<pcwidth>)
	      ~ %memspace{$memspace}<label>;
      $pc_str = sprintf($pcformat, $pc);
      say sprintf "%s %s", $pc_str, $symbol;
    }
  }
}

#######
#
# Here's where we put the machine specific stuff
#
#######

#######
#
# End of machine specific stuff
#
#######

# START HERE
for @*ARGS -> $arg {
  if $arg ~~ /^\-s/ {
    $s1file = ~$arg;
    $s1file ~~ s/^\-s//;
    next;
  }
  unshift @files, $arg; # last file specified will be first in list
}

{
#  my $*OUT = open '/dev/null', :w;
  do_pass(1+0);
}

do_pass(+2);

#say "Assembly completed!!!";
print_symbols();

if $s1file {
  write_s1($s1file);
}
