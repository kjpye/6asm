#!/usr/local/bin/perl6

use v6;

my %param = (codewidth => 9,
             pcwidth   => 8,
            );

my %directive = ();

my @local_pointer = ();
my @local_symbol = ();

my %memspace;
my Int $pc;
my @memspace = ({'pc' => 0.Int});

sub setup_local_pointer() {
    for 0..99 -> $index {
	@local_pointer[$index] = -1;
    }
}

sub setup_local() {
    for 0..99 -> $index {
	@local_symbol[$index] = [];
    }
    # setup_local_pointer() is called in do_pass
}

setup_local();

my %symbol = ();

my $isa = '';
my %instructions;

# This should be a macro!
sub make_hash(Str $isa, Str $instr) {
  %instructions{$isa}{$instr}<array> = "{$isa}_instr_{$instr}";
}

# Variables required for AVR

my @avr_instr_inh;      make_hash('avr', 'inh');
my @avr_instr_rr;       make_hash('avr', 'rr');
my @avr_instr_ww;       make_hash('avr', 'ww');
my @avr_instr_rr3;      make_hash('avr', 'rr3');
my @avr_instr_rr4;      make_hash('avr', 'rr4');
my @avr_instr_r2;       make_hash('avr', 'r2');
my @avr_instr_r;        make_hash('avr', 'r');
my @avr_instr_r_reg;    make_hash('avr', 'r_reg');
my @avr_instr_iw;       make_hash('avr', 'iw');
my @avr_instr_ir;       make_hash('avr', 'ir');
my @avr_instr_i6r;      make_hash('avr', 'i6r');
my @avr_instr_out;      make_hash('avr', 'out');
my @avr_instr_irc;      make_hash('avr', 'irc');
my @avr_instr_sreg;     make_hash('avr', 'sreg');
my @avr_instr_tbit;     make_hash('avr', 'tbit');
my @avr_instr_brb;      make_hash('avr', 'brb');
my @avr_instr_branch;   make_hash('avr', 'branch');
my @avr_instr_lbranch;  make_hash('avr', 'lbranch');
my @avr_instr_long;     make_hash('avr', 'long');
my @avr_instr_lds;      make_hash('avr', 'lds');
my @avr_instr_sts;      make_hash('avr', 'sts');
my @avr_instr_bio;      make_hash('avr', 'bio');
my @avr_instr_i4;       make_hash('avr', 'i4');
my @avr_instr_rx;       make_hash('avr', 'rx');
my @avr_instr_xr;       make_hash('avr', 'xr');
my @avr_instr_rxplus;   make_hash('avr', 'rxplus');
my @avr_instr_xrplus;   make_hash('avr', 'xrplus');
my @avr_instr_rxminus;  make_hash('avr', 'rxminus');
my @avr_instr_xrminus;  make_hash('avr', 'xrminus');
my @avr_instr_ry;       make_hash('avr', 'ry');
my @avr_instr_yr;       make_hash('avr', 'yr');
my @avr_instr_ryplus;   make_hash('avr', 'ryplus');
my @avr_instr_yrplus;   make_hash('avr', 'yrplus');
my @avr_instr_ryminus;  make_hash('avr', 'ryminus');
my @avr_instr_yrminus;  make_hash('avr', 'yrminus');
my @avr_instr_ryq;      make_hash('avr', 'ryq');
my @avr_instr_yrq;      make_hash('avr', 'yrq');
my @avr_instr_rz;       make_hash('avr', 'rz');
my @avr_instr_stzr;     make_hash('avr', 'stzr');
my @avr_instr_rzplus;   make_hash('avr', 'rzplus');
my @avr_instr_zrplus;   make_hash('avr', 'zrplus');
my @avr_instr_rzminus;  make_hash('avr', 'rzminus');
my @avr_instr_zrminus;  make_hash('avr', 'zrminus');
my @avr_instr_rzq;      make_hash('avr', 'rzq');
my @avr_instr_zrq;      make_hash('avr', 'zrq');
my @avr_instr_z;        make_hash('avr', 'z');
my @avr_instr_zr;       make_hash('avr', 'zr');
my @avr_instr_zplus;    make_hash('avr', 'zplus');
my @avr_instr_noz;      make_hash('avr', 'noz');

# Variables required for PIC

my @pic10_instr_inh;      make_hash('pic10', 'inh');
my @pic10_instr_byte;     make_hash('pic10', 'byte');
my @pic10_instr_bytes;    make_hash('pic10', 'bytes');
my @pic10_instr_bit;      make_hash('pic10', 'bit');
my @pic10_instr_lit;      make_hash('pic10', 'lit');
my @pic10_instr_goto;     make_hash('pic10', 'goto');
my @pic10_instr_tris;     make_hash('pic10', 'tris');

my @pic18_instr_inh;      make_hash('pic18', 'inh');
my @pic18_instr_bytefda;  make_hash('pic18', 'bytefda');
my @pic18_instr_bytefa;   make_hash('pic18', 'bytefa');
my @pic18_instr_byteff;   make_hash('pic18', 'byteff');
my @pic18_instr_bit;      make_hash('pic18', 'bit');
my @pic18_instr_branch;   make_hash('pic18', 'branch');
my @pic18_instr_lbranch;  make_hash('pic18', 'lbranch');
my @pic18_instr_call;     make_hash('pic18', 'call');
my @pic18_instr_ret;      make_hash('pic18', 'ret');
my @pic18_instr_lit;      make_hash('pic18', 'lit');
my @pic18_instr_bsr;      make_hash('pic18', 'bsr');
my @pic18_instr_tblrd;    make_hash('pic18', 'tblrd');

# Variables required for mc6809

my @mc6809_instr_inh;   make_hash('mc6809', 'inh');
my @mc6809_instr_imm8;  make_hash('mc6809', 'imm8');
my @mc6809_instr_imm16; make_hash('mc6809', 'imm16');
my @mc6809_instr_die;   make_hash('mc6809', 'die');
my @mc6809_instr_br;    make_hash('mc6809', 'br');
my @mc6809_instr_lbr;   make_hash('mc6809', 'lbr');
my @mc6809_instr_tfr;   make_hash('mc6809', 'tfr');
my @mc6809_instr_psh;   make_hash('mc6809', 'psh');

# Variables required for standard ARM instruction set

my @arm_instr_inh;      make_hash('arm', 'inh');
my @arm_instr_mul;      make_hash('arm', 'mul');
my @arm_instr_mla;      make_hash('arm', 'mla');
my @arm_instr_mull;     make_hash('arm', 'mull');
my @arm_instr_sds;      make_hash('arm', 'sds');
my @arm_instr_brx;      make_hash('arm', 'brx');
my @arm_instr_hdt;      make_hash('arm', 'hdt');
my @arm_instr_sdt;      make_hash('arm', 'sdt');
my @arm_instr_bdt;      make_hash('arm', 'bdt');

# Variables required for ARM thumb instruction sets

my @thumb_instr_inh;    make_hash('thumb', 'inh');
my @thumb_instr_arimm;  make_hash('thumb', 'arimm');

sub mkexp {
  my ($value, $def) = @_;
  #say "Making expression from $value, $def";
  return {value => $value, def => $def};
}

grammar Assembler {

# basic rules for expressions

    token id                      { <wb> ( <[a..z A..Z _ $]> <[a..z A..Z 0..9 _ \.]>* ) <wb> }
    token identifier              { <id>
                                    {
#say "Found identifier: ", $/;
                                      my $sym = ~$/<id>;
                                      my $lcsym = $sym.lc;
                                      if %symbol{$lcsym}.defined {
                                        my $val = %symbol{$sym.lc}<value>;
                                        make mkexp($val, 1);
                                      } else {
                                        error_listing "*** Undefined symbol \"$sym\"";
                                        make mkexp(0, 0);
                                      }
                                    }
                                  }
    token localref                { (\d\d?) ( <[fFbB]> )
                                    {
                                      my $value;
                                      my $def = 1; # assume backwards ref
                                      my $index = +$/[0];
                                      my $index2 = @local_pointer[$index];
                                      if ~$/[1] eq 'f' | 'F' {
                                        ++$index2;
                                        $def = 0;
                                      }
                                  #say "In method local_ref: index is $index ($index2)";
                                      if $index2 < 0 {
                                        $value = 0; # Should be error
                                      } else {
                                        $value = 0;
                                        $value = @local_symbol[$index][$index2] if @local_symbol[$index][$index2].defined;
                                      }
                                      make mkexp($value, $def);
                                    }
                                  }
    token plusminus               { < + - >?                        { make $/ eq '-' ?? -1 !! 1;            } }
    proto token number            { <*>                                                                       }
    token number:sym<decimal>     { <plusminus> ( <[0..9]>+ )       { make $/<plusminus>.made * :10(~$/[0]); } }
    token number:sym<binary>      { '0' <[bB]> <[01]>+              { make :2(~$/);                         } }
    token number:sym<octal>       { '0' <[oO]> <[0..7]>+            { make :8(~$/);                         } }
    token number:sym<hex>         { '0' <[Xx]> <[0..9 a..f A..F]>+  { make :16(~$/);                        } }
    token number:sym<hex2>        {     '$'   (<[0..9 a..f A..F]>+) { make :16(~$/[0]);                     } }
    proto rule term               { <*>                                                                       }
    rule term:sym<localref>       { <localref>                      { make $/<localref>.made;                } }
    rule term:sym<number>         { <number>                        { make mkexp($/<number>.made, 1);        } }
    rule term:sym<funcall>        { $<identifier>=(low|LOW|high|HIGH) '(' <expression> ')'
                                    {
                                      my $def = $/<expression>.made<def>;
                                      if $/<identifier>.lc eq 'low' {
                                        make mkexp($/<expression>.made<value> +& 0xff, $def);
                                      }
                                      if $/<identifier>.lc eq 'high' {
                                        make mkexp( ($/<expression>.made<value> +> 8) +& 0xff, $def);
                                      }
                                    }
                                  }
    rule term:sym<identifier>     { <identifier>                    { make $/<identifier>.made;             } }
    rule term:sym<pexpr>          {'(' <expression> ')'             { make $/<expression>.made;             } }
    token addoper                 { '+' | '-'                                                                 }
    token muloper                 { '*' | '/' | '%' | '<<' | '>>'                                             }
    rule mulexpr                  { <term> [ <muloper> <term> ]*
                                    {
                                      my $value = +$/<term>[0].made<value>;
                                      my $def   = +$/<term>[0].made<def>;
                                      if ?$/<muloper> {
                                        for 0 .. (+$/<muloper> - 1) -> $index {
	                                  my $oper = ~$/<muloper>[$index];
	                                  if $oper ~~ '*' {
	                                    $value *= $/<term>[$index + 1].made<value>;
	                                  } elsif $oper ~~ '/' {
	                                    $value /= $/<term>[$index + 1].made<value>;
	                                  } elsif $oper ~~ '%' {
	                                    $value %= $/<term>[$index + 1].made<value>;
	                                  } elsif $oper ~~ '<<' {
	                                    $value +<= $/<term>[$index + 1].made<value>;
	                                  } elsif $oper ~~ '>>' {
	                                    $value +>= $/<term>[$index + 1].made<value>;
	                                  } else {
	                                    error_listing "Illegal operator";
	                                  }
                                          $def &= $/<term>[$index + 1].made<def>
                                        }
                                      }
                                      make mkexp($value, $def);
                                    }
                                  }
    rule expression               { [ <mulexpr> [ <addoper> <mulexpr> ]* ]
                                    {
                                      my $value = $/<mulexpr>[0].made<value>;
                                      my $def   = $/<mulexpr>[0].made<def>;
                                      if ?$/<addoper> {
                                        for 0 .. (+$<addoper> - 1) -> $index {
	                                  my $oper = ~$/<addoper>[$index];
	                                  if $oper ~~ '+' {
	                                    $value += $/<mulexpr>[$index + 1].made<value>;
	                                  } else {
	                                    $value -= $/<mulexpr>[$index + 1].made<value>;
	                                  }
                                          $def &= $/<mulexpr>[$index + 1].made<def>;
                                        }
                                      }
                                      make mkexp($value, $def);
                                    }
                                  }
    proto token string            { <*>                                                                       }
    token string:sym<singlequote> { \' ( <[a..z A..Z 0..9 <ws>]>* ) \' { make ~$/[0];                       } }
    rule stringexpression         { <string>                           { make ~$/<string>.made;              } }
    proto regex instruction       { <*>                                                                       }
    token comma                   { <.ws>? ',' <.ws>?                                                         }
}

my %instructionset;
%instructionset<assembler> = Assembler.new();
my $instructionset = %instructionset<assembler>;

# Rules for AVR

grammar Avr is Assembler {
  rule avr_bit                       { <expression>
                                       { ##### should be avr specific
                                         my $val = $/<expression>.made;
                                         if 0 <= $val <= 7 {
                                           make $val;
                                         } else {
                                          error_listing '*** Bit number out of range';
                                          make 0;
                                         }
                                       }
                                     }
  token avr_reg                      { <ws>? <wb> <[rR]> ( \d+ ) [ '+' (\d+) ]?
                                       {
                                         my  $reg = $/[0];
#say "Found avr_reg: ", $/;
                                         if $/[1].defined {
                                           my $offset = $/[1];
                                           $reg += $offset;
                                         }
                                         if ! (0 <= $reg <= 31) {
                                           error_listing '*** Registers must be in range r0 to r31';
                                           $reg = 0;
                                         }
                                         make $reg;
                                       }
                                     }
  token avr_regpair                  { <[rR]> ( \d+ ) ':' <[rR]>? ( \d+ )
                                       {
                                         my $r1 = $/[0];
                                         my $r2 = $/[1];
                                         error_listing ('*** Illegal register pair') unless ($r1 == $r2 + 1) && ($r1 +& 1);
                                         make $r2;
                                       }
                                     }
  regex instruction:sym<avr_rr>      { $<mnemonic>=@avr_instr_rr      <avr_reg> <comma> <avr_reg> <ws>
                                       {
                                         my $opcode = %instructions<avr><rr><hash>{~$/<mnemonic>};
                                         my $r1 = +$/<avr_reg>[0].made;
                                         my $r2 = +$/<avr_reg>[1].made;
                                         $opcode +|= ($r1 +< 4) +& 0x1f0;
                                         $opcode +|=  $r2       +& 0x0f;
                                         $opcode +|= ($r2 +< 5) +& 0x200;
                                         make( ($opcode,) ); # don't remove the comma!
                                       }
                                     }
  regex instruction:sym<avr_ww1>     { $<mnemonic>=@avr_instr_ww      <avr_regpair> <comma> <avr_regpair> <ws>
                                       {
                                         my $opcode = %instructions<avr><ww><hash>{~$/<mnemonic>};
                                         my $r1 = +$/<regpair>[0].made;
                                         my $r2 = +$/<regpair>[1].made;
                                         $opcode +|= ($r1 +< 3) +& 0x00f0;
                                         $opcode +|= ($r2 +> 1) +& 0x000f;
                                         make( ($opcode,) ); # don't remove the comma!
                                       }
                                     }
  regex instruction:sym<avr_ww2>     { $<mnemonic>=@avr_instr_ww      <avr_reg> <comma> <avr_reg> <ws> 
                                       {
                                         my $opcode = %instructions<avr><ww><hash>{~$/<mnemonic>};
                                         my $r1 = +$/<avr_reg>[0].made;
                                         my $r2 = +$/<avr_reg>[1].made;
                                         $opcode +|= ($r1 +< 3) +& 0x00f0;
                                         $opcode +|= ($r2 +> 1) +& 0x000f;
                                         make( ($opcode,) ); # don't remove the comma!
                                       }
                                     }
  regex instruction:sym<avr_rr3>     { $<mnemonic>=@avr_instr_rr3     <avr_reg> <comma> <avr_reg> <ws>
                                       {
                                         my $opcode = %instructions<avr><rr3><hash>{~$/<mnemonic>};
                                         my $r1 = +$/<avr_reg>[0].made;
                                         my $r2 = +$/<avr_reg>[1].made;
                                         if ( (16 <= $r1 < 24) && (16 <= $r2 < 24) ) {
                                           $opcode +|= ($r1 +< 4) +& 0x0070;
                                           $opcode +|=  $r2       +& 0x0007;
                                         } else {
                                           error_listing '*** Registers must be in range 16 to 23';
                                         }
                                         make( ($opcode,) ); # don't remove the comma!
                                       }
                                     }
  regex instruction:sym<avr_rr4>     { $<mnemonic>=@avr_instr_rr4     <avr_reg> <comma> <avr_reg> <.ws> 
                                       {
                                         my $opcode = %instructions<avr><rr4><hash>{~$/<mnemonic>};
                                         my $r1 = +$/<avr_reg>[0].made;
                                         my $r2 = +$/<avr_reg>[1].made;
                                         if ( (16 <= $r1 < 32) && (16 <= $r2 < 32) ) {
                                           $opcode +|= ($r1 +< 4) +& 0x00f0;
                                           $opcode +|=  $r2       +& 0x000f;
                                         } else {
                                           error_listing '*** Registers must be in range 16 to 31';
                                         }
                                         make( ($opcode,) ); # don't remove the comma!
                                       }
                                     }
  regex instruction:sym<avr_r2>      { $<mnemonic>=@avr_instr_r2   <avr_reg> <ws> 
                                       {
                                         my $opcode = %instructions<avr><r2><hash>{~$/<mnemonic>};
                                         my $r1 = +$/<avr_reg>.made;
                                         $opcode +|= ($r1 +< 4) +& 0x1f0;
                                         $opcode +|=  $r1       +& 0x0f;
                                         $opcode +|= ($r1 +< 5) +& 0x200;
                                         make( ($opcode,) ); # don't remove the comma!
                                       }
                                     }
  regex instruction:sym<avr_r>       { $<mnemonic>=@avr_instr_r       <avr_reg> <ws> 
                                       {
                                         my $opcode = %instructions<avr><r><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_inh>     { $<mnemonic>=@avr_instr_inh     <ws>
                                       {
                                         my $opcode = %instructions<avr><inh><hash>{~$/<mnemonic>};
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_iw>      { $<mnemonic>=@avr_instr_iw      <ws> <avr_regpair> <comma> <expression> <ws> 
                                       {
                                         my $opcode = %instructions<avr><iw><hash>{~$/<mnemonic>};
                                         my $reg = $/<regpair>.made;
                                         my $val = $/<expression>.made<value>;
                                         if ($reg < 24) || ($reg +& 1) {
                                           error_listing('*** Register must be r25:r24, r27:r26, r29:r28 or r31:r30');
                                           $reg = 24;
                                         }
                                         $opcode +|= ($reg +< 1) +& 0x0030;
                                         $opcode +|=  $val       +& 0x000f;
                                         $opcode +|= ($val +< 2) +& 0x00c0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_iw2>     { $<mnemonic>=@avr_instr_iw      <ws> <avr_reg> <comma> <expression> <ws> 
                                       {
                                         my $opcode = %instructions<avr><iw><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         my $val = $/<expression>.made<value>;
                                         if ($reg < 24) || ($reg +& 1) {
                                           error_listing('*** Register must be r24, r26, r28 or r30');
                                           $reg = 24;
                                         }
                                         $opcode +|= ($reg +< 1) +& 0x0030;
                                         $opcode +|=  $val       +& 0x000f;
                                         $opcode +|= ($val +< 2) +& 0x00c0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_ir>      { $<mnemonic>=@avr_instr_ir     <ws> <avr_reg> <comma> <expression> <ws> 
                                       {
                                         my $opcode = %instructions<avr><ir><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         my $val = $/<expression>.made<value>;
                                         if $reg < 16 {
                                           error_listing('*** Register must be r16 - r31');
                                           $reg = 16;
                                         }
                                         $opcode +|= ($reg +< 4) +& 0x00f0;
                                         $opcode +|=  $val       +& 0x000f;
                                         $opcode +|= ($val +< 4) +& 0x0f00;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_irc>     { $<mnemonic>=@avr_instr_irc     <ws> <avr_reg> <comma> <expression> <ws> 
                                       {
                                         my $opcode = %instructions<avr><irc><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         my $val = $/<expression>.made<value> +^ 0xff;
                                         if $reg < 16 {
                                           error_listing('*** Register must be r16 - r31');
                                           $reg = 16;
                                         }
                                         $opcode +|= ($reg +< 4) +& 0x00f0;
                                         $opcode +|=  $val       +& 0x000f;
                                         $opcode +|= ($val +< 4) +& 0x0f00;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_sreg>    { $<mnemonic>=@avr_instr_sreg    <ws> <avr_bit> <ws> 
                                       {
                                         my $opcode = %instructions<avr><sreg><hash>{~$/<mnemonic>};
                                         my $bit = $/<avr_bit>.made;
                                         $opcode +|= ($bit +< 4) +& 0x0070;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_tbit>    { $<mnemonic>=@avr_instr_tbit    <ws> <avr_reg> <comma> <avr_bit> <ws> 
                                       {
                                         my $opcode = %instructions<avr><tbit><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         my $bit = $/<avr_bit>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         $opcode +|=  $bit       +& 0x0007;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_brb>     { $<mnemonic>=@avr_instr_brb     <ws> <avr_bit> <comma> <expression> <ws> 
                                       {
                                         my $opcode = %instructions<avr><brb><hash>{~$/<mnemonic>};
                                         my $bit = $/<avr_bit>.made;
                                         my $target = $/<expression>.made<value>;
                                         my $offset = $target - $pc - 1;
                                         error_listing "*** Branch out of range (from $pc to $target)" if $offset > 63 || $offset < -64;
                                         $opcode +|= ($offset +< 3) +& 0x03f0;
                                         $opcode +|=  $bit          +& 0x0007;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_branch>  { $<mnemonic>=@avr_instr_branch  <ws> <expression> <ws> 
                                       {
                                         my $opcode = %instructions<avr><branch><hash>{~$/<mnemonic>};
                                         my $target = $/<expression>.made<value>;
                                         my $offset = $target - $pc - 1;
                                         error_listing "*** Branch out of range (from $pc to $target)" if $offset > 63 || $offset < -64;
                                         $opcode +|= ($offset +< 3) +& 0x03f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_lbranch> { $<mnemonic>=@avr_instr_lbranch <ws> <expression> <ws> 
                                       {
                                         my $opcode = %instructions<avr><lbranch><hash>{~$/<mnemonic>};
                                         my $target = $/<expression>.made<value>;
                                         my $offset = $target - $pc - 1;
                                         error_listing "*** Branch out of range (from $pc to $target)" if $offset > 2047 || $offset < -2048;
                                         $opcode +|= $offset +& 0x0fff;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_long>    { $<mnemonic>=@avr_instr_long    <ws> <expression> <ws> 
                                       {
                                         my $opcode = %instructions<avr><long><hash>{~$/<mnemonic>};
                                         my $target = $/<expression>.made<value>;
                                         $opcode +|= ($target +> 16) +& 0x0001;
                                         $opcode +|= ($target +> 13) +& 0x01f0;
                                         make ( ($opcode,($target +& 0xffff)) );
                                       }
                                     }
  regex instruction:sym<avr_lds>     { $<mnemonic>=@avr_instr_lds     <ws> <avr_reg> <comma> <expression> <ws> 
                                       {
                                       # TODO: Handle 7-bit address variant
                                         my $opcode = %instructions<avr><lds><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         my $addr = $/<expression>.made<value>;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,($addr +& 0xffff)) );
                                       }
                                     }
  regex instruction:sym<avr_sts>     { $<mnemonic>=@avr_instr_sts     <ws> <expression> <comma> <avr_reg> <ws> 
                                       {
                                       # TODO: Handle 7-bit address variant
                                         my $opcode = %instructions<avr><sts><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         my $addr = $/<expression>.made<value>;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,($addr +& 0xffff)) );
                                       }
                                     }
  regex instruction:sym<avr_bio>     { $<mnemonic>=@avr_instr_bio     <ws> <expression> <comma> <avr_bit> <ws>
                                       {
                                         my $opcode = %instructions<avr><bio><hash>{~$/<mnemonic>};
                                         my $bit = $/<avr_bit>.made;
                                         my $reg = $/<expression>.made<value>;
                                         error_listing '*** I/O register must be in range 0 to 31' if $reg < 0 || $reg >= 32;
                                         $opcode +|=  $bit       +& 0x0007;
                                         $opcode +|= ($reg +< 3) +& 0x00f8;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_i4>      { $<mnemonic>=@avr_instr_i4      <ws> <expression> <ws>
                                       {
                                         my $opcode = %instructions<avr><i4><hash>{~$/<mnemonic>};
                                         my $round = $/<expression>.made<value>;
                                         error_listing '*** Round must be in range 0 to 15' if $round < 0 || $round >= 16;
                                         $opcode +|= ($round +< 4) +& 0x00f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_rx>      { $<mnemonic>=@avr_instr_rx      <ws> <avr_reg> <comma> <[xX]> <!before '+'> <ws>
                                       {
                                         my $opcode = %instructions<avr><rx><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_xr>      { $<mnemonic>=@avr_instr_xr      <ws> <[xX]> <comma> <avr_reg> <ws>
                                       {
                                         my $opcode = %instructions<avr><xr><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_rxplus>  { $<mnemonic>=@avr_instr_rxplus  <ws> <avr_reg> <comma> <[xX]>'+' <ws>
                                       {
                                         my $opcode = %instructions<avr><rxplus><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_xrplus>  { $<mnemonic>=@avr_instr_xrplus  <ws> <[xX]>'+' <comma> <avr_reg> <ws>
                                       {
                                         my $opcode = %instructions<avr><xrplus><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_rxminus> { $<mnemonic>=@avr_instr_rxminus <ws> <avr_reg> <comma> '-'<[xX]> <ws>
                                       {
                                         my $opcode = %instructions<avr><rxminus><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_xrminus> { $<mnemonic>=@avr_instr_xrminus <ws> '-'<[xX]> <comma> <avr_reg> <ws> 
                                       {
                                         my $opcode = %instructions<avr><xrminus><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_ry>      { $<mnemonic>=@avr_instr_ry      <ws> <avr_reg> <comma> <[yY]> <!before '+'> <ws>
                                       {
                                         my $opcode = %instructions<avr><ry><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_yr>      { $<mnemonic>=@avr_instr_yr      <ws> <[yY]> <comma> <avr_reg> <ws>
                                       {
                                         my $opcode = %instructions<avr><yr><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_ryplus>  { $<mnemonic>=@avr_instr_ryplus  <ws> <avr_reg> <comma> <[yY]>'+' <!before <expression> > <ws>
                                       {
                                         my $opcode = %instructions<avr><ryplus><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_yrplus>  { $<mnemonic>=@avr_instr_yrplus  <ws> <[yY]>'+' <comma> <avr_reg> <ws>
                                       {
                                         my $opcode = %instructions<avr><yrplus><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_ryminus> { $<mnemonic>=@avr_instr_ryminus <ws> <avr_reg> <comma> '-'<[yY]> <ws>
                                       {
                                         my $opcode = %instructions<avr><ryminus><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_yrminus> { $<mnemonic>=@avr_instr_yrminus <ws> '-'<[yY]> <comma> <avr_reg> <ws>
                                       {
                                         my $opcode = %instructions<avr><yrminus><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_ryq>     { $<mnemonic>=@avr_instr_ryq     <ws> <avr_reg> <comma> <[yY]> '+' <expression> <ws>
                                       {
                                         my $opcode = %instructions<avr><ryq><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         my $val = $/<expression>.made<value>;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         if 0 <= $val <= 63 {
                                           $opcode +|=  $val       +& 0x0007;
                                           $opcode +|= ($val +< 7) +& 0x0c00;
                                           $opcode +|= ($val +< 8) +& 0x1000;
                                         } else {
                                           error_listing '*** Offset must be 0 to 63';
                                         }
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_yrq>     { $<mnemonic>=@avr_instr_yrq     <ws> <[yY]> '+' <expression> <comma> <avr_reg> <ws>
                                       {
                                         my $opcode = %instructions<avr><yrq><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         my $val = $/<expression>.made<value>;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         if 0 <= $val <= 63 {
                                           $opcode +|=  $val       +& 0x0007;
                                           $opcode +|= ($val +< 7) +& 0x0c00;
                                           $opcode +|= ($val +< 8) +& 0x1000;
                                         } else {
                                           error_listing '*** Offset must be 0 to 63';
                                         }
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_rz>      { $<mnemonic>=@avr_instr_rz      <ws> <avr_reg> <comma> <[zZ]> <!before '+' > <ws>
                                       {
                                         my $opcode = %instructions<avr><rz><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_stzr>    { $<mnemonic>=@avr_instr_stzr    <ws> <[zZ]> <comma> <avr_reg> <ws>
                                       {
                                         my $opcode = %instructions<avr><stzr><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_rzplus>  { $<mnemonic>=@avr_instr_rzplus  <ws> <avr_reg> <comma> <[zZ]>'+' <ws>
                                       {
                                         my $opcode = %instructions<avr><rzplus><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_zrplus>  { $<mnemonic>=@avr_instr_zrplus  <ws> <[zZ]>'+' <comma> <avr_reg> <ws>
                                       {
                                         my $opcode = %instructions<avr><zrplus><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_rzminus> { $<mnemonic>=@avr_instr_rzminus <ws> <avr_reg> <comma> '-'<[zZ]> <ws>
                                       {
                                         my $opcode = %instructions<avr><rzminus><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_zrminus> { $<mnemonic>=@avr_instr_zrminus <ws> '-'<[zZ]> <comma> <avr_reg> <ws>
                                       {
                                         my $opcode = %instructions<avr><zrminus><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_rzq>     { $<mnemonic>=@avr_instr_rzq     <ws> <avr_reg> <comma> <[zZ]> '+' <expression> <ws>
                                       {
                                         my $opcode = %instructions<avr><rzq><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         my $val = $/<expression>.made<value>;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         if 0 <= $val <= 63 {
                                           $opcode +|=  $val       +& 0x0007;
                                           $opcode +|= ($val +< 7) +& 0x0c00;
                                           $opcode +|= ($val +< 8) +& 0x1000;
                                         } else {
                                           error_listing '*** Offset must be 0 to 63';
                                         }
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_zrq>     { $<mnemonic>=@avr_instr_zrq     <ws> <[zZ]> '+' <expression> <comma> <avr_reg> <ws>
                                       {
                                         my $opcode = %instructions<avr><zrq><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         my $val = $/<expression>.made<value>;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         if 0 <= $val <= 63 {
                                           $opcode +|=  $val       +& 0x0007;
                                           $opcode +|= ($val +< 7) +& 0x0c00;
                                           $opcode +|= ($val +< 8) +& 0x1000;
                                         } else {
                                           error_listing '*** Offset must be 0 to 63';
                                         }
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_zr>      { $<mnemonic>=@avr_instr_zr      <ws> <[zZ]> <comma> <avr_reg> <ws>
                                       {
                                         my $opcode = %instructions<avr><zr><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_zplus>   { $<mnemonic>=@avr_instr_zplus   <ws> <avr_reg> <comma> <[zZ]>'+' <ws>
                                       {
                                         my $opcode = %instructions<avr><zplus><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         $opcode +|= ($reg +< 4) +& 0x01f0;
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_noz>     { $<mnemonic>=@avr_instr_noz     <ws>
                                       {
                                         my $opcode = %instructions<avr><noz><hash>{~$/<mnemonic>};
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_i6r>     { $<mnemonic>=@avr_instr_i6r     <ws> <avr_reg> <comma> <expression> <ws> 
                                       {
                                         my $opcode = %instructions<avr><i6r><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         my $val = $/<expression>.made<value>;
                                         if 0 <= $val <= 63 {
                                           $opcode +|= ($reg +< 4) +& 0x01f0;
                                           $opcode +|=  $val       +& 0x000f;
                                           $opcode +|= ($val +< 4) +& 0x0f00;
                                         } else {
                                           error_listing '*** Location must be 0 to 63';
                                         }
                                         make ( ($opcode,) );
                                       }
                                     }
  regex instruction:sym<avr_out>     { $<mnemonic>=@avr_instr_out     <ws> <expression> <comma> <avr_reg> <ws> 
                                       {
                                         my $opcode = %instructions<avr><out><hash>{~$/<mnemonic>};
                                         my $reg = $/<avr_reg>.made;
                                         my $val = $/<expression>.made<value>;
                                         if 0 <= $val <= 63 {
                                           $opcode +|= ($reg +< 4) +& 0x01f0;
                                           $opcode +|=  $val       +& 0x000f;
                                           $opcode +|= ($val +< 4) +& 0x0f00;
                                         } else {
                                           error_listing '*** Location must be 0 to 63';
                                         }
                                         make ( ($opcode,) );
                                       }
                                     }
}

%instructionset<avr> = Avr.new();

# Rules for PIC

grammar Pic10 is Assembler {
  token pic10_bit                     { <expression>
                                        {
                                          my  $reg = +$/;
                                          if ! (0 <= $reg <= 7) {
                                            error_listing '*** bit number must be between 0 and 7';
                                            $reg = 0;
                                          }
                                          make $reg;
                                        }
                                      }
  token pic10_d                       { <expression>
                                        {
                                          my  $reg = +$/;
                                          if ! (0 <= $reg <= 1) {
                                            error_listing '*** D must be 0 or 1';
                                            $reg = 0;
                                          }
                                          make $reg;
                                        }
                                      }
  token pic10_f                       { <expression> 
                                        {
                                          my  $reg = +$/;
                                          if ! (0 <= $reg <= 31) {
                                            error_listing '*** Registers must be in range 0 to 31';
                                            $reg = 0;
                                          }
                                          make $reg;
                                        }
                                      }
  regex instruction:sym<pic10_inh>    { $<mnemonic>=@pic10_instr_inh     <.ws>
                                        {
                                          my $opcode = %instructions<pic10><inh><hash>{~$/<mnemonic>};
                                          make ( ($opcode,) );
                                        }
                                      }
  regex instruction:sym<pic10_byte>   { $<mnemonic>=@pic10_instr_byte    <.ws> <pic10_f> <comma> <pic10_d>
                                        {
                                          my $opcode = %instructions<pic10><byte><hash>{~$/<mnemonic>};
                                          $opcode +|= $/<pic10_f>.made;
                                          $opcode +|= $/<pic10_d>.made +< 5;
                                          make ( ($opcode,) );
                                        }
                                      }
  regex instruction:sym<pic10_bytes>  { $<mnemonic>=@pic10_instr_bytes   <.ws> <pic10_f>
                                        {
                                          my $opcode = %instructions<pic10><bytes><hash>{~$/<mnemonic>};
                                          $opcode +|= $/<pic10_f>.made;
                                          make ( ($opcode,) );
                                        }
                                      }
  regex instruction:sym<pic10_bit>    { $<mnemonic>=@pic10_instr_bit     <.ws> <pic10_f> <comma> <pic10_bit>
                                        {
                                          my $opcode = %instructions<pic10><bit><hash>{~$/<mnemonic>};
                                          $opcode +|= $/<pic10_f>.made;
                                          $opcode +|= $/<pic10_bit>.made +< 5;
                                          make ( ($opcode,) );
                                        }
                                      }
  regex instruction:sym<pic10_lit>    { $<mnemonic>=@pic10_instr_lit     <.ws> <expression>
                                        {
                                          my $opcode = %instructions<pic10><lit><hash>{~$/<mnemonic>};
                                          $opcode +|= $/<expression>.made<value> +& 0xff;
                                          make ( ($opcode,) );
                                        }
                                      }
  regex instruction:sym<pic10_goto>   { $<mnemonic>=@pic10_instr_goto    <.ws> <expression>
                                        {
                                          my $opcode = %instructions<pic10><goto><hash>{~$/<mnemonic>};
                                          $opcode +|= $/<expression>.made<value> +& 0x1ff;
                                          make ( ($opcode,) );
                                        }
                                      }
  regex instruction:sym<pic10_tris>   { $<mnemonic>=@pic10_instr_tris    <.ws> <pic10_f>
                                        {
                                          my $opcode = %instructions<pic10><tris><hash>{~$/<mnemonic>};
                                          my $file = +$/<pic10_f>.made;
                                          if $file != 6 | 7 {
                                            error_listing 'Register file for this instruction must be 6 or 7';
                                            $file = 6;
                                          }
                                          $opcode +|= $file;
                                          make ( ($opcode,) );
                                        }
                                      }
                                    }

%instructionset<pic10> = Pic10.new();

grammar Pic18 is Assembler {
  token pic18_a                       { <expression>
                                        {
                                          my  $reg = +$/;
                                          if ! (0 <= $reg <= 1) {
                                            error_listing '*** A must be 0 or 1';
                                            $reg = 0;
                                          }
                                          make $reg;
                                        }
                                      }
  token pic18_d                       { <expression>
                                        {
                                          my  $reg = +$/;
                                          if ! (0 <= $reg <= 1) {
                                            error_listing '*** D must be 0 or 1';
                                            $reg = 0;
                                          }
                                          make $reg;
                                        }
                                      }
  token pic18_f                       { <expression>
                                        {
                                          my  $reg = +$/;
                                          if ! (0 <= $reg <= 255) {
                                            error_listing '*** Registers must be in range 0 to 255';
                                            $reg = 0;
                                          }
                                          make $reg;
                                        }
                                      }
  token pic18_bit                     { <expression>
                                        {
                                          my  $reg = +$/;
                                          if ! (0 <= $reg <= 7) {
                                            error_listing '*** bit number must be between 0 and 7';
                                            $reg = 0;
                                          }
                                          make $reg;
                                        }
                                      }
  regex instruction:sym<pic18_inh>     { $<mnemonic>=@pic18_instr_inh     <.ws>
                                         {
                                           my $opcode = %instructions<pic18><inh><hash>{~$/<mnemonic>};
                                           make ( ($opcode,) );
                                         }
                                       }
  regex instruction:sym<pic18_bytefda> { $<mnemonic>=@pic18_instr_bytefda <.ws> <pic18_f> <comma> <pic18_d> <comma> <pic18_a> <ws>
                                         {
                                           my $opcode = %instructions<pic18><bytefda><hash>{~$/<mnemonic>};
                                           my $f = $/<pic18_f>.made;
                                           my $d = $/<pic18_d>.made;
                                           my $a = $/<pic18_a>.made;
                                           $opcode +|= $f;
                                           $opcode +|= $a +< 8;
                                           $opcode +|= $d +< 9;
                                           make ( ($opcode,) );
                                         }
                                       }
  regex instruction:sym<pic18_bytefa>  { $<mnemonic>=@pic18_instr_bytefa  <.ws> <pic18_f> <comma> <pic18_a> <ws>
                                         {
                                           my $opcode = %instructions<pic18><bytefa><hash>{~$/<mnemonic>};
                                           my $f = $/<pic18_f>.made;
                                           my $a = $/<pic18_a>.made;
                                           $opcode +|= $f;
                                           $opcode +|= $a +< 8;
                                           make ( ($opcode,) );
                                         }
                                       }
  regex instruction:sym<pic18_byteff>  { $<mnemonic>=@pic18_instr_byteff  <.ws> <expression> <comma> <expression> <ws>
                                         {
                                           my $opcode = %instructions<pic18><byteff><hash>{~$/<mnemonic>};
                                           my $fs = $/<expression>[0].made<value> +& 0x0fff;
                                           my $fd = $/<expression>[1].made<value> +& 0x0fff;
                                           $opcode +|= $fs;
                                           make ( ($opcode, 0xf000 +| $fd) );
                                         }
                                       }
  regex instruction:sym<pic18_bitm>    { $<mnemonic>=@pic18_instr_bit     <.ws> <pic18_f> <comma> <pic18_bit> <comma> <pic18_a> <ws>
                                         {
                                           my $opcode = %instructions<pic18><bit><hash>{~$/<mnemonic>};
                                           my $f = $/<pic18_f>.made;
                                           my $b = $/<pic18_bit>.made;
                                           my $a = $/<pic18_a>.made;
                                           $opcode +|= $f;
                                           $opcode +|= $a +< 8;
                                           $opcode +|= $b +< 9;
                                           make ( ($opcode,) );
                                         }
                                       }
  regex instruction:sym<pic18_branch>  { $<mnemonic>=@pic18_instr_branch  <.ws> <expression>
                                         {
                                           my $opcode = %instructions<pic18><branch><hash>{~$/<mnemonic>};
                                           my $target = $/<expression>.made<value>;
                                           my $offset = $target - $pc - 1;
                                           if ($offset < -128 || $offset > 127) {
                                           }
                                           $offset +&= 0xff;
                                           $opcode +|= $offset;
                                           make ( ($opcode,) );
                                         }
                                       }
  regex instruction:sym<pic18_lbranch> { $<mnemonic>=@pic18_instr_lbranch <.ws> <expression>
                                         {
                                           my $opcode = %instructions<pic18><lbranch><hash>{~$/<mnemonic>};
                                           my $target = $/<expression>.made<value>;
                                           my $offset = $target - $pc - 1;
                                           if ($offset < -1024 || $offset > 1023) {
                                           }
                                           $offset +&= 0x3ff;
                                           $opcode +|= $offset;
                                           make ( ($opcode,) );
                                         }
                                       }
  regex instruction:sym<pic18_call>    { $<mnemonic>=@pic18_instr_call    <.ws> <expression> [ <comma> <expression> ] ?
                                         {
                                           my $opcode = %instructions<pic18><call><hash>{~$/<mnemonic>};
                                           my $target = $/<expression>[0].made<value>;
                                           $target +&= 0x0fffff;
                                           $opcode +|= $target +& 0x0fff;
                                           $opcode +|= 0x0100 if defined $/<expression>[1] && $/<expression>[1].made<value> != 0;
                                           make ( ($opcode, 0xf000 + ($target +> 12)) );
                                         }
                                       }
  regex instruction:sym<pic18_ret>     { $<mnemonic>=@pic18_instr_ret     <.ws> <expression> ?
                                         {
                                           my $opcode = %instructions<pic18><ret><hash>{~$/<mnemonic>};
                                           $opcode +|= 0x0001 if defined $/<expression> && $/<expression>.made<value> != 0;
                                           make ( ($opcode,) );
                                         }
                                       }
  regex instruction:sym<pic18_lit>     { $<mnemonic>=@pic18_instr_lit     <.ws> <expression>
                                         {
                                           my $opcode = %instructions<pic18><lit><hash>{~$/<mnemonic>};
                                           my $imm = $/<expression>.made<value>;
                                           $imm +&= 0xff;
                                           make ( ($opcode +| $imm,) );
                                         }
                                       }
  regex instruction:sym<pic18_bsr>     { $<mnemonic>=@pic18_instr_bsr     <.ws> <expression>
                                         {
                                           my $opcode = %instructions<pic18><bsr><hash>{~$/<mnemonic>};
                                           my $imm = $/<expression>.made<value>;
                                           $imm +&= 0x0f;
                                           make ( ($opcode +| $imm,) );
                                         }
                                       }
  regex instruction:sym<pic18_tblrd>   { $<mnemonic>=@pic18_instr_tblrd   <.ws> ('*'|'*+'|'*-'|'+*')
                                         {
                                           my $opcode = %instructions<pic18><tblrd><hash>{~$/<mnemonic>};
                                           my $type = ~$/[0];
                                           $opcode +|= 0x0001 if $type eq '*+';
                                           $opcode +|= 0x0002 if $type eq '*-';
                                           $opcode +|= 0x0003 if $type eq '+*';
                                           make ( ($opcode,) );
                                         }
                                       }
}

%instructionset<pic18> = Pic18.new();

# Rules for mc6809

grammar Mc6809 is Assembler {
  token mc6809_acc                    { < a b >
                                        {
                                          my  $acc = ~$/;
                                          make $acc eq 'a' ?? 0 !! 1;
                                        }
                                      }
  token mc6809_acc16                  { 'd'                                                                                      }
  token mc6809_reg16                  { < x y u s >
                                        {
                                          my  $acc = ~$/;
                                          my %mc6809_reg16 = ('x' => 0, 'y' => 1, 'u' => 2, 's' => 3);
                                          make %mc6809_reg16{$acc};
                                        }
                                      }
  token mc6809_anyreg                 { < a b cc dp x y u s d pc >
                                        {
                                          my $reg = ~$/;
                                          my %mc6809_anyreg = ('d' => 0, 'x' => 1, 'y' => 2, 'u' => 3, 's' => 4, 'pc' => 5, 'a' => 8, 'b' => 9, 'cc' => 10, 'dp' => 11);
                                          make %mc6809_anyreg{$reg};
                                        }
                                      }
  proto regex mc6809_idx              { <*>                                                                                      }
  regex mc6809_idx:sym<off>           { <expression> <comma> <mc6809_reg16>
                                        {
                                          my $def = $/<expression>.made<def>;
                                          my $value = $/<expression>.made<value>;
                                          my $reg = $/<mc6809_reg16>.made;
                                          my $made = 0;
                                          if $def {
                                            if $value == 0 {
                                              make ( (0x84 +| $reg +< 5, ));
                                              $made = 1;
                                            } elsif -16 <= $value <= 15 {
                                              make ( (0x00 +| ($reg +< 5) +| $value +& 0x1f, ));
                                              $made = 1;
                                            } elsif -128 <= $value <= 127 {
                                              my $postbyte = 0x88;
                                              $postbyte +|= $reg +< 5;
                                              make ( ( $postbyte, $value ) );
                                              $made = 1;
                                            }
                                          } 
                                          if ! $made {
                                            make ( (0x89 +| ($reg +< 5), ($value +> 8), ($value +& 0xff)));
                                          }
                                        }
                                      }
  regex mc6809_idx:sym<accoff>        { < a b d > <comma> <mc6809_reg16>                                                             }
  regex mc6809_idx:sym<postinc>       { <comma> <mc6809_reg16> ('+' ** 0..2)
                                        {
                                          my $reg = $/<mc6809_reg16>.made;
                                          my $postinc = ~$/[0].chars;
                                          my $postbyte = 0x84;
                                          $postbyte = 0x80 if $postinc == 1;
                                          $postbyte = 0x81 if $postinc == 2;
                                          make ( ($postbyte +| ($reg +< 5), ));
                                        }
                                      }
  regex mc6809_idx:sym<predec>        { <comma> ('-' ** 1..2) <mc6809_reg16>
                                        {
                                          my $reg = $/<mc6809_reg16>.made;
                                          my $postinc = ~$/[0].chars;
                                          my $postbyte = 0x84;
                                          $postbyte = 0x82 if $postinc == 1;
                                          $postbyte = 0x83 if $postinc == 2;
                                          make ( ($postbyte +| ($reg +< 5), ));
                                        }
                                      }
  regex mc6809_idx:sym<pcrel>         { <expression> ',pcr'
                                        {
                                          my $target = $/<expression>.made<value>;
                                          my $def    = $/<expression>.made<def>;
                                          my $offset = $target - $pc; # fix for instruction length
                                          # assume 16-bit offset for now
                                          make ( (0x8d, $offset +> 8, $offset) );
                                        }
                                      }
  regex instruction:sym<mc6809_inh>   { $<mnemonic>=@mc6809_instr_inh  <.ws>
                                        {
                                          my $opcode = %instructions<mc6809><inh><hash>{~$/<mnemonic>};
                                          if ($opcode > 0xff) {
                                            make ( ($opcode +> 8, $opcode +& 0xff) );
                                          } else {
                                            make ( ($opcode,) );
                                          }
                                        }
                                      }
  regex instruction:sym<mc6809_imm8>  { $<mnemonic>=@mc6809_instr_imm8 <.ws> '#' <expression>
                                        {
                                          my $opcode = %instructions<mc6809><imm8><hash>{~$/<mnemonic>};
                                          my $imm = +$/<expression>.made<value> +& 0xff;
                                          if ($opcode > 0xff) {
                                            make ( ($opcode +> 8, $opcode +& 0xff, $imm) );
                                          } else {
                                            make ( ($opcode, $imm) );
                                          }
                                        }
                                      }
  regex instruction:sym<mc6809_imm16> { $<mnemonic>=@mc6809_instr_imm16 <.ws> '#' <expression>
                                        {
                                          my $opcode = %instructions<mc6809><imm16><hash>{~$/<mnemonic>};
                                          my $imm = +$/<expression>.made<value> +& 0xffff;
                                          if ($opcode > 0xff) {
                                            make ( ($opcode +> 8, $opcode +& 0xff, $imm +> 8, $imm +& 0xff) );
                                          } else {
                                            make ( ($opcode, $imm +> 8, $imm +& 0xff) );
                                          }
                                        }
                                      }
  regex instruction:sym<mc6809_dir>   { $<mnemonic>=@mc6809_instr_die <.ws> '<' <expression> <!before <comma> >
                                        {
                                          my $opcode = %instructions<mc6809><die><hash>{~$/<mnemonic>};
                                          $opcode +|= 0x10; # direct addressing mode
                                          $opcode +&= 0x8f if $opcode +& 0xf0 == 0x40; # ugh -- so much for orthogonality
                                          my $imm = +$/<expression>.made<value> +& 0xff;
                                          if ($opcode > 0xff) {
                                            make ( ($opcode +> 8, $opcode +& 0xff, $imm) );
                                          } else {
                                            make ( ($opcode, $imm) );
                                          }
                                        }
                                      }
  regex instruction:sym<mc6809_ind1>  { $<mnemonic>=@mc6809_instr_die <.ws> <mc6809_idx>
                                        {
                                          my $opcode = %instructions<mc6809><die><hash>{~$/<mnemonic>};
                                          $opcode +|= 0x20; # indexed addressing mode
                                          my @postbytes = $/<mc6809_idx>.made;
                                          if ($opcode > 0xff) {
                                            make ( ($opcode +> 8, $opcode +& 0xff, @postbytes) );
                                          } else {
                                            make ( ($opcode, @postbytes) );
                                          }
                                        }
                                      }
  regex instruction:sym<mc6809_ind2>  { $<mnemonic>=@mc6809_instr_die <.ws> '[' <mc6809_idx> ']'
                                        {
                                          my $opcode = %instructions<mc6809><die><hash>{~$/<mnemonic>};
                                          $opcode +|= 0x20; # indexed addressing mode
                                          my @postbytes = $/<mc6809_idx>.made;
                                          @postbytes[0] +|= 0x10; # set indirect bit -- TODO fix 5 bit offsets
                                          if ($opcode > 0xff) {
                                            make ( ($opcode +> 8, $opcode +& 0xff, @postbytes) );
                                          } else {
                                            make ( ($opcode, @postbytes) );
                                          }
                                        }
                                      }
  regex instruction:sym<mc6809_ind3>  { $<mnemonic>=@mc6809_instr_die <.ws> '[' <expression> ']'
                                        {
                                          my $opcode = %instructions<mc6809><die><hash>{~$/<mnemonic>};
                                          $opcode +|= 0x20; # indexed addressing mode
                                          if ($opcode > 0xff) {
                                            make ( ($opcode +> 8, $opcode +& 0xff, 0x9f, +$/<expression>.made<value> +> 8, +$/<expression>.made<value> +& 0xff) );
                                          } else {
                                            make ( ($opcode, 0x9f, +$/<expression>.made<value> +> 8, +$/<expression>.made<value> +& 0xff) );
                                          }
                                        }
                                      }
  regex instruction:sym<mc6809_ext>   { $<mnemonic>=@mc6809_instr_die <.ws> <expression> <!before <comma> >
                                        {
                                          my $opcode = %instructions<mc6809><die><hash>{~$/<mnemonic>};
                                          my $imm = $/<expression>.made<value> +& 0xffff;
                                          my $def = $/<expression>.made<def>;
                                          if $def && ($imm +> 8) == %param<dp> {
	                                      # use direct addressing
                                            $opcode +|= 0x10; # direct addressing mode
                                            $opcode +&= 0x8f if $opcode +& 0xf0 == 0x40; # ugh -- so much for orthogonality
                                            my $imm = +$/<expression>.made<value> +& 0xff;
                                            if ($opcode > 0xff) {
                                              make ( ($opcode +> 8, $opcode +& 0xff, $imm) );
                                            } else {
                                              make ( ($opcode, $imm) );
                                            }
                                          } else {
                                            $opcode +|= 0x30; # extended addressing mode
                                            if ($opcode > 0xff) {
                                              make ( ($opcode +> 8, $opcode +& 0xff, $imm +> 8, $imm +& 0xff) );
                                            } else {
                                              make ( ($opcode, $imm +> 8, $imm +& 0xff) );
                                            }
                                          }
                                        }
                                      }
  regex instruction:sym<mc6809_br>    { $<mnemonic>=@mc6809_instr_br  <.ws> <expression>
                                        {
                                          my $opcode = %instructions<mc6809><br><hash>{~$/<mnemonic>};
                                          my $imm = +$/<expression>.made<value> +& 0xffff;
                                          my $offset = $imm - ($pc + 2);
                                          if ($opcode > 0xff) {
                                            --$offset;
                                            make ( ($opcode +> 8, $opcode +& 0xff, $offset +& 0xff) );
                                          } else {
                                            make ( ($opcode, $offset +& 0xff) );
                                          }
                                        }
                                      }
  regex instruction:sym<mc6809_lbr>   { $<mnemonic>=@mc6809_instr_lbr <.ws> <expression>
                                        {
                                          my $opcode = %instructions<mc6809><lbr><hash>{~$/<mnemonic>};
                                          my $imm = +$/<expression>.made<value> +& 0xffff;
                                          my $offset = $imm - ($pc + 2);
                                          if ($opcode > 0xff) {
                                            --$offset;
                                            make ( ($opcode +> 8, $opcode +& 0xff, ($offset +> 8) +& 0xff, $offset +& 0xff) );
                                          } else {
                                            make ( ($opcode, ($offset +> 8) +& 0xff, $offset +& 0xff) );
                                          }
                                        }
                                      }
  regex instruction:sym<mc6809_tfr>   { $<mnemonic>=@mc6809_instr_tfr <.ws> <mc6809_anyreg> <.ws>? <comma> <.ws>? <mc6809_anyreg>
                                        {
                                          my $opcode = %instructions<mc6809><tfr><hash>{~$/<mnemonic>};
                                          my $postbyte = ($/<mc6809_anyreg>[0].made +< 4) +| $/<mc6809_anyreg>[1].made;
                                          make ( ($opcode, $postbyte) );
                                        }
                                      }
  regex instruction:sym<mc6809_psh>   { $<mnemonic>=@mc6809_instr_psh <.ws> <mc6809_anyreg>+ % <comma>
                                        {
                                          my $opcode = %instructions<mc6809><psh><hash>{~$/<mnemonic>};
                                          my $postbyte = 0;
                                          for @($/<mc6809_anyreg>) -> $reg {
                                            if $reg eq 'd' {
                                              if $postbyte +& 0x06 {
                                                 error_listing "*** Register d conflicts with previous register specification";
                                              }
                                              $postbyte +|= 0x06;
                                            }
                                            if $reg eq 'x' {
                                              if $postbyte +& 0x10 {
                                                 error_listing "*** Register x conflicts with previous register specification";
                                              }
                                              $postbyte +|= 0x10;
                                            }
                                            if $reg eq 'y' {
                                              if $postbyte +& 0x20 {
                                                 error_listing "*** Register y conflicts with previous register specification";
                                              }
                                              $postbyte +|= 0x20;
                                            }
                                            if $reg eq 'u' | 's' {
                                              if $postbyte +& 0x40 {
                                                 error_listing "*** Register u/s conflicts with previous register specification";
                                              }
                                              $postbyte +|= 0x40;
                                            }
                                            if $reg eq 'pc' {
                                              if $postbyte +& 0x80 {
                                                 error_listing "*** Register pc conflicts with previous register specification";
                                              }
                                              $postbyte +|= 0x80;
                                            }
                                            if $reg eq 'a' {
                                              if $postbyte +& 0x02 {
                                                 error_listing "*** Register a conflicts with previous register specification";
                                              }
                                              $postbyte +|= 0x02;
                                            }
                                            if $reg eq 'b' {
                                              if $postbyte +& 0x04 {
                                                 error_listing "*** Register b conflicts with previous register specification";
                                              }
                                              $postbyte +|= 0x04;
                                            }
                                            if $reg eq 'cc' {
                                              if $postbyte +& 0x01 {
                                                 error_listing "*** Register cc conflicts with previous register specification";
                                              }
                                              $postbyte +|= 0x01;
                                            }
                                            if $reg eq 'dp' {
                                              if $postbyte +& 0x08 {
                                                 error_listing "*** Register dp conflicts with previous register specification";
                                              }
                                              $postbyte +|= 0x08;
                                            }
                                          }
                                          make ( ($opcode, $postbyte) );
                                        }
                                      }
}

%instructionset<mc6809> = Mc6809.new();

# Rules for ARM

grammar Arm is Assembler {
  token arm_reg                       { <[rR]> ( \d+ ) [ '+' (\d+) ]?
                                        {
                                          my $reg = +$/[0];
                                          if $/[1].defined {
                                            $reg += $/[1];
                                          }
                                          if ! (0 <= $reg <= 15) {
                                            error_listing '*** Registers must be in range r0 to r15';
                                            $reg = 0;
                                          }
                                          make $reg;
                                        }
                                      }
  regex arm_rrange                    { <arm_reg> [ '-' <arm_reg> ]?
                                        {
                                          my $regs = 0;
                                          my $start = +$/<arm_reg>[0].made;
                                          my $end   = ($/<arm_reg>[1].defined) ?? +$/<arm_reg>[1].made !! $start;
                                          for $start..$end -> $r {
                                            $regs +|= 1 +< $r;
                                          }
                                          make ($regs);
                                        }
                                      }
  regex arm_rlist                     { '{' <arm_rrange>+ % <comma> '}'
                                        {
                                          my $regs = 0;
                                          for @($/<arm_reg>) -> $r {
                                            $regs +|= $r.made;
                                          }
                                          make ($regs);
                                        }
                                      }
  token arm_cond                      { < eq ne cs cc mi pl vs vc hi ls ge lt gt le al >?
                                        {
                                          my %arm_cond = ('eq' => 0, 'ne' => 1, 'cs' => 2, 'cc' => 3, 'mi' => 4, 'pl' => 5, 'vs' => 6, 'vc' => 7, 'hi' => 8, 'ls' => 9, 'ge' => 10, 'lt' => 11, 'gt' => 12, 'le' => 13, 'al' => 14, '' => 14);
                                          my $cond = 14; # default to "always"
                                          $cond = %arm_cond{~$/} if ~$/.defined;
                                          make ($cond +<= 28); # shift to where the instruction will use it
                                        }
                                      }
  token arm_setcond                   { 's'?
                                        {
                                          my $setcond = (~$/ eq 's') ?? 0x01 !! 0x00;
                                          make ($setcond);
                                        }
                                      }
  token arm_byte                      { 'b'?
                                        {
                                          my $byte    = (~$/ eq 'b') ?? 0x01 !! 0x00;
                                          make ($byte);
                                        }
                                      }
}

grammar Armfull is Arm {
  proto regex arm_shift               { <*>                                                                                      }
  regex arm_shift:sym<imm>            { < lsl ror lsr asr > '#' <expression>                                                     }
  regex arm_shift:sym<reg>            { < lsl ror lsr asr > <arm_reg>                                                            }
  regex arm_shift:sym<rrx>            { 'rrx' <arm_reg>                                                                          }
  regex arm_bdttype                   { < fd ed fa ea ia ib da db >                                                              }
  proto regex arm_hdtaddr             { <*>                                                                                      }
  regex arm_hdtaddr:sym<expr>         { <expression>
                                        {
                                          my $offset = $/<expression>.made - $pc - 8;
                                      # TODO Check for offset more than 8 bits either direction
                                          if ($offset < 0) {
                                            $offset = -$offset;
                                            make (0x01cf0090 +| (($offset +< 4) +& 0x0f00) +| ($offset +& 0x000f));
                                          } else {
                                            make (0x014f0090 +| (($offset +< 4) +& 0x0f00) +| ($offset +& 0x000f));
                                          }
                                        }
                                      }
  regex arm_hdtaddr:sym<reg>          { '[' <arm_reg> ']' <!before <comma> >
                                        {
                                          make (0x01400090 +| $/<arm_reg>.made +< 16;);
                                        }
                                      }
  regex arm_hdtaddr:sym<preimm>       { '[' <arm_reg> <comma> '#' <expression> ']' ('!'?)
                                        {
                                          my $offset = $/<expression>.made;
                                      # TODO Check for offset more than 8 bits either direction
                                          my $postbyte = 0x01400090;
                                          if ($offset < 0) {
                                            $offset = -$offset;
                                            $postbyte +|= 0x00800000;
                                          }
                                          $postbyte +|= $/<arm_reg>.made +< 16;
                                          make ($postbyte +| (($offset +< 4) +& 0x0f00) +| ($offset +& 0x000f));
                                        }
                                      }
  regex arm_hdtaddr:sym<preind>       { '[' <arm_reg> <comma> <plusminus> <arm_reg> ']' ('!'?)
                                        {
                                          my $postbyte = 0x01000090;
                                          if ($/<plusminus>.made > 0) {
                                            $postbyte +|= 0x00800000;
                                          }
                                          $postbyte +|= 1 +< 21 if $/[0] eq '!';
                                          $postbyte +|= $/<arm_reg>[0].made +< 16;
                                          $postbyte +|= $/<arm_reg>[1].made;
                                          make ($postbyte);
                                        }
                                      }
  regex arm_hdtaddr:sym<postimm>      { '[' <arm_reg> ']' <comma> '#' <expression>
                                        {
                                          my $offset = $/<expression>.made;
                                      # TODO Check for offset more than 8 bits either direction
                                          my $postbyte = 0x01400090;
                                          if ($offset < 0) {
                                            $offset = -$offset;
                                            $postbyte +|= 0x00800000;
                                          }
                                          $postbyte +|= $/<arm_reg>.made +< 16;
                                          make ($postbyte +| (($offset +< 4) +& 0x0f00) +| ($offset +& 0x000f));
                                        }
                                      }
  regex arm_hdtaddr:sym<postind>      { '[' <arm_reg> ']' <comma>  <plusminus> <arm_reg>
                                        {
                                          my $postbyte = 0x00000090;
                                          if ($/<plusminus>.made > 0) {
                                            $postbyte +|= 0x00800000;
                                          }
                                          $postbyte +|= $/<arm_reg>[0].made +< 16;
                                          $postbyte +|= $/<arm_reg>[1].made;
                                          make ($postbyte);
                                        }
                                      }
  proto regex arm_sdtaddr             { <*>                                                                                      }
  regex arm_sdtaddr:sym<expr>         { <expression>
                                        {
                                          my $offset = $/<expression>.made - $pc - 8;
                                      # TODO Check for offset more than 8 bits either direction
                                          if ($offset < 0) {
                                            $offset = -$offset;
                                            make (0x01800000 +| (($offset +< 4) +& 0x0f00) +| ($offset +& 0x000f));
                                          } else {
                                            make (0x01000000 +| (($offset +< 4) +& 0x0f00) +| ($offset +& 0x000f));
                                          }
                                        }
                                      }
  regex arm_sdtaddr:sym<reg>          { '[' <arm_reg> ']' <!before <comma> >
                                        {
                                          make (0x01000000 +| $/<arm_reg>.made +< 16;);
                                        }
                                      }
  regex arm_sdtaddr:sym<preimm>       { '[' <arm_reg> <comma> '#' <expression> ']' ('!'?)
                                        {
                                          my $offset = $/<expression>.made;
                                      # TODO Check for offset more than 8 bits either direction
                                          my $postbyte = 0x03000000;
                                          if ($offset < 0) {
                                            $offset = -$offset;
                                          } else {
                                            $postbyte +|= 0x00800000;
                                          }
                                          $postbyte +|= $/<arm_reg>.made +< 16;
                                          $postbyte +|= (($offset +< 4) +& 0x0f00) +| ($offset +& 0x000f);
                                          make ($postbyte);
                                        }
                                      }
  regex arm_sdtaddr:sym<preind>       { '[' <arm_reg> <comma> <plusminus> <arm_reg> ( <comma> <arm_shift> )? ']' ('!'?)          }
  regex arm_sdtaddr:sym<postimm>      { '[' <arm_reg> ']' <comma> '#' <expression>                                               }
  regex arm_sdtaddr:sym<postind>      { '[' <arm_reg> ']' <comma>  <plusminus> <arm_reg> ( <comma> <arm_shift> )?                }
  regex arm_sbh                       { < h sb sh >
                                        {
                                          my %arm_sbh = ('h' => 0xb0, 'sb' => 0xd0, 'sh' => 0xf0, '' => 0xb0);
                                          make (%arm_sbh{~$/});
                                        }
                                      }
  regex arm_t                         { 't'?                                                                                     }
  regex instruction:sym<arm_inh>      { $<mnemonic>=@arm_instr_inh  <arm_cond>               <.ws>
                                        {
                                          my $opcode = %instructions<arm><inh><hash>{~$/<mnemonic>};
                                          my $cond = $/<arm_cond>.made;
                                          $opcode +|= $cond;
                                          make ( ($opcode,) );
                                        }
                                      }
  regex instruction:sym<arm_mul>      { $<mnemonic>=@arm_instr_mul  <arm_cond> <arm_setcond> <.ws> <arm_reg> ** 3..3 % <comma>
                                        {
                                          my $opcode = %instructions<arm><mul><hash>{~$/<mnemonic>};
                                          $opcode +|= $/<arm_cond>.made;
                                          $opcode +|= $/<arm_setcond>.made +< 20;
                                          $opcode +|= $/<arm_reg>[0].made +< 16;
                                          $opcode +|= $/<arm_reg>[1].made;
                                          $opcode +|= $/<arm_reg>[2].made +< 8;
                                          make ( ($opcode,) );
                                        }
                                      }
  regex instruction:sym<arm_mla>      { $<mnemonic>=@arm_instr_mla  <arm_cond> <arm_setcond> <.ws> <arm_reg> ** 4..4 % <comma>
                                        {
                                          my $opcode = %instructions<arm><mla><hash>{~$/<mnemonic>};
                                          $opcode +|= $/<arm_cond>.made;
                                          $opcode +|= $/<arm_setcond>.made +< 20;
                                          $opcode +|= $/<arm_reg>[0].made +< 16;
                                          $opcode +|= $/<arm_reg>[1].made;
                                          $opcode +|= $/<arm_reg>[2].made +< 8;
                                          $opcode +|= $/<arm_reg>[3].made +< 12;
                                          make ( ($opcode,) );
                                        }
                                      }
  regex instruction:sym<arm_mull>     { $<mnemonic>=@arm_instr_mull <arm_cond> <arm_setcond> <.ws> <arm_reg> ** 4..4 % <comma>
                                        {
                                          my $opcode = %instructions<arm><mull><hash>{~$/<mnemonic>};
                                      # TODO: check for valid register combinations
                                          $opcode +|= $/<arm_cond>.made;
                                          $opcode +|= $/<arm_setcond>.made +< 20;;
                                          $opcode +|= $/<arm_reg>[0].made +< 12;
                                          $opcode +|= $/<arm_reg>[1].made +< 16;
                                          $opcode +|= $/<arm_reg>[2].made;
                                          $opcode +|= $/<arm_reg>[3].made +< 8;
                                          make ( ($opcode,) );
                                        }
                                      }
  regex instruction:sym<arm_sds>      { $<mnemonic>=@arm_instr_sds  <arm_cond> <arm_byte>    <.ws> <arm_reg> ** 2 % <comma> <comma> '[' <arm_reg> ']'
                                        {
                                          my $opcode = %instructions<arm><sds><hash>{~$/<mnemonic>};
                                          $opcode +|= $/<arm_cond>.made;
                                          $opcode +|= $/<arm_byte>.made +< 22;
                                          $opcode +|= $/<arm_reg>[0].made +< 12;
                                          $opcode +|= $/<arm_reg>[1].made;
                                          $opcode +|= $/<arm_reg>[2].made +< 16;
                                          make ( ($opcode,) );
                                        }
                                      }
  regex instruction:sym<arm_brx>      { $<mnemonic>=@arm_instr_brx  <arm_cond>               <.ws> <arm_reg>
                                        {
                                          my $opcode = %instructions<arm><brx><hash>{~$/<mnemonic>};
                                          $opcode +|= $/<arm_cond>.made;
                                          $opcode +|= $/<arm_reg>.made;
                                          make ( ($opcode,) );
                                        }
                                      }
  regex instruction:sym<arm_hdt>      { $<mnemonic>=@arm_instr_hdt  <arm_cond> <arm_sbh>     <.ws> <arm_reg> <comma> <arm_hdtaddr>
                                        {
                                          my $opcode = %instructions<arm><hdt><hash>{~$/<mnemonic>};
                                          $opcode +|= $/<arm_cond>.made;
                                          $opcode +|= $/<arm_hdtaddr>.made;
                                          $opcode +|= $/<arm_sbh>.made;
                                          make ( ($opcode,) );
                                        }
                                      }
  regex instruction:sym<arm_sdt>      { $<mnemonic>=@arm_instr_sdt  <arm_cond> <arm_byte> <arm_t> <.ws> <arm_reg> <comma> <arm_sdtaddr>       }
  regex instruction:sym<arm_bdt>      { $<mnemonic>=@arm_instr_bdt  <arm_cond> <arm_bdttype> <.ws> <arm_reg> ('!')? <comma> <arm_rlist> ('^')? }

}

%instructionset<armfull> = Armfull.new();

grammar Thumb is Arm {
  token thumb_width                  { [ '.' (<[nNwW]>) ]?
                                       { if $/[0].defined {
                                           if $/[0] ~~ /<[nN]>/ {
                                             make 16;
                                           } else {
                                             make 32;
                                           }
                                         } else {
                                           make 0;
                                         }
                                       }
                                     }
  token thumb_imm                    { '#' <expression>
                                       {
                                         make 0 if $/<expression>.made == 0; # the simplest case
                                         make $/<expression> if $/<expression> +& 0xffffff00 == 0; # also easy (and makes the previous case superfluous!)
                                         make (0x00001000 +| ($/<expression>.made +& 0x000000ff))
                                           if (($/<expression> +& 0xff00ff00 == 0)
                                           && (($/<expression>.made +&0x000000ff) == (($/<expression>.made +> 16) +& 0x000000ff)));
                                         make (0x00002000 +| (($/<expression>.made +> 8) +& 0x000000ff))
                                           if (($/<expression> +& 0x00ff00ff == 0)
                                           && (($/<expression>.made +&0x0000ff00) == (($/<expression>.made +> 16) +& 0x0000ff00)));
                                         make (0x00003000 +| ($/<expression>.made +& 0x000000ff))
                                           if (($/<expression>.made +&0x000000ff) == (($/<expression>.made +>  8) +& 0x000000ff))
                                           && (($/<expression>.made +&0x000000ff) == (($/<expression>.made +> 16) +& 0x000000ff))
                                           && (($/<expression>.made +&0x000000ff) == (($/<expression>.made +> 24) +& 0x000000ff));
                                         make 0x00004000 +| (($/<expression>.made +& 0x7f000000) +> 24) if $/<expression>.made +& 0x80ffffff == 0x80000000;
                                         make 0x00004080 +| (($/<expression>.made +& 0x3f800000) +> 23) if $/<expression>.made +& 0xc07fffff == 0x40000000;
                                         make 0x00005000 +| (($/<expression>.made +& 0x1fc00000) +> 22) if $/<expression>.made +& 0xe03fffff == 0x20000000;
                                         make 0x00005080 +| (($/<expression>.made +& 0x0fe00000) +> 21) if $/<expression>.made +& 0xf01fffff == 0x10000000;
                                         make 0x00006000 +| (($/<expression>.made +& 0x07f00000) +> 20) if $/<expression>.made +& 0xf80fffff == 0x08000000;
                                         make 0x00006080 +| (($/<expression>.made +& 0x03f80000) +> 19) if $/<expression>.made +& 0xfc07ffff == 0x04000000;
                                         make 0x00007000 +| (($/<expression>.made +& 0x01fc0000) +> 18) if $/<expression>.made +& 0xfe03ffff == 0x02000000;
                                         make 0x00007080 +| (($/<expression>.made +& 0x00fe0000) +> 17) if $/<expression>.made +& 0xff01ffff == 0x01000000;
                                         make 0x04000000 +| (($/<expression>.made +& 0x007f0000) +> 16) if $/<expression>.made +& 0xff80ffff == 0x00800000;
                                         make 0x04000080 +| (($/<expression>.made +& 0x003f8000) +> 15) if $/<expression>.made +& 0xffc07fff == 0x00400000;
                                         make 0x04001000 +| (($/<expression>.made +& 0x001fc000) +> 14) if $/<expression>.made +& 0xffe03fff == 0x00200000;
                                         make 0x04001080 +| (($/<expression>.made +& 0x000fe000) +> 13) if $/<expression>.made +& 0xfff01fff == 0x00100000;
                                         make 0x04002000 +| (($/<expression>.made +& 0x0007f000) +> 12) if $/<expression>.made +& 0xfff80fff == 0x00080000;
                                         make 0x04002080 +| (($/<expression>.made +& 0x0003f800) +> 11) if $/<expression>.made +& 0xfffc07ff == 0x00040000;
                                         make 0x04003000 +| (($/<expression>.made +& 0x0001fc00) +> 10) if $/<expression>.made +& 0xfffe03ff == 0x00020000;
                                         make 0x04003080 +| (($/<expression>.made +& 0x0000fe00) +>  9) if $/<expression>.made +& 0xffff01ff == 0x00010000;
                                         make 0x04004000 +| (($/<expression>.made +& 0x00007f00) +>  8) if $/<expression>.made +& 0xffff80ff == 0x00008000;
                                         make 0x04004080 +| (($/<expression>.made +& 0x00003f80) +>  7) if $/<expression>.made +& 0xffffc07f == 0x00004000;
                                         make 0x04005000 +| (($/<expression>.made +& 0x00001fc0) +>  6) if $/<expression>.made +& 0xffffe03f == 0x00002000;
                                         make 0x04005080 +| (($/<expression>.made +& 0x00000fe0) +>  5) if $/<expression>.made +& 0xfffff01f == 0x00001000;
                                         make 0x04006000 +| (($/<expression>.made +& 0x000007f0) +>  4) if $/<expression>.made +& 0xfffff80f == 0x00000800;
                                         make 0x04006080 +| (($/<expression>.made +& 0x000003f8) +>  3) if $/<expression>.made +& 0xfffffc07 == 0x00000400;
                                         make 0x04007000 +| (($/<expression>.made +& 0x000001fc) +>  2) if $/<expression>.made +& 0xfffffe03 == 0x00000200;
                                         make 0x04007080 +| (($/<expression>.made +& 0x000000fe) +>  1) if $/<expression>.made +& 0xffffff01 == 0x00000100;
### TODO Fail otherwise
                                       }
                                     }
  regex instruction:sym<thumb_arimm> { $<mnemonic>=@thumb_instr_arimm <arm_setcond> <arm_cond> <thumb_width> <.ws> [$<dest>=<arm_reg> <comma>]? $<src>=<arm_reg> <comma> <thumb_imm>
                                       {
                                         my $opcode = %instructions<thumb><arimm><hash>{~$/<mnemonic>};
                                         $opcode +|= $/<thumb_imm>.made;
                                         make ( ($opcode,) );
                                       }
                                     }
}

%instructionset<thumb> = Thumb.new();

class Assembler::Actions {

  method arm_sdtaddr:sym<preind>($/) {
    my $postbyte = 0x03000090;
    if ($/<plusminus>.made > 0) {
      $postbyte +|= 0x00800000;
    }
    $postbyte +|= 1 +< 21 if $/[0] eq '!';
    $postbyte +|= $/<arm_reg>[0].made +< 16;
    $postbyte +|= $/<arm_reg>[1].made;
    make ($postbyte);
  }
  method arm_sdtaddr:sym<postimm>($/) {
    my $offset = $/<expression>.made;
# TODO Check for offset more than 8 bits either direction
    my $postbyte = 0x00000000;
    if ($offset < 0) {
      $offset = -$offset;
    } else {
      $postbyte +|= 0x00800000;
    }
    $postbyte +|= $/<arm_reg>.made +< 16;
    $postbyte +|= (($offset +< 4) +& 0x0f00) +| ($offset +& 0x000f);
    make ($postbyte);
  }
  method arm_sdtaddr:sym<postind>($/) {
    my $postbyte = 0x00000000;
    if ($/<plusminus>.made > 0) {
      $postbyte +|= 0x00800000;
    }
    $postbyte +|= $/<arm_reg>[0].made +< 16;
    $postbyte +|= $/<arm_reg>[1].made;
    make ($postbyte);
  }
  method instruction:sym<arm_sdt>($/) {
    my $opcode = %instructions<arm><sdt><hash>{~$/<mnemonic>};
    $opcode +|= $/<arm_cond>.made;
    $opcode +|= $/<arm_byte>.made +< 22;
    $opcode +|= $/<arm_sdtaddr>.made;
    make ( ($opcode,) );
  }

}

# Input routines

my $input_line = sub { return Str; };
my $line_number = 0;

sub
include_file(Str $filename) {
  my $HANDLE = open $filename, :r;
  my $old_input_line = $input_line;
  my $old_line_number = $line_number;
  $line_number = 0;
  $input_line = sub {
    my $line = $HANDLE.get;
    if ! $line.defined {
      $input_line = $old_input_line;
      $line_number = $old_line_number;
      if $input_line.defined {
	return $input_line();
      } else {
	return Str;
      }
    }
    ++$line_number;
    return $line;
  };
}

my %macro = ();
my $current_macro_def = '';
my $ifdepth = 0;
my $truedepth = 0;
my %define = ();

sub
expand_macro(Str $label, Str $opcode, Str $rest) {
  my $old_input_line = $input_line;
  my $old_line_number = $line_number;
  $line_number = 0;
  my $macro_name = $opcode;
  my $index = 0;
  my @args = $rest.comb(/
			<?after \"> <-[\"]>+ <?before \"> # stuff in quotes
			| \w+                                # or words
			/);
  $index = 0;
  $input_line = sub {
    my $line = %macro{$macro_name}[$index++];
    if ! $line.defined {
      $input_line = $old_input_line;
      $line_number = $old_line_number;
      if $input_line.defined {
	return $input_line();
      } else {
	return Str;
      }
    }
    # interpolate the arguments
#    say "Interpolating arguments ", @args.perl, " into $line\n";
    while ($line ~~ m/\@(<digit>)/) {
      my $value = @args[$/[0]];
      $line ~~ s/\@<digit>/{$value}/;
    }
    ++$line_number;
    return $line;
  };
}

sub
parse_line(Str $line) {
  my $tline = $line;
  my Str $label = '';
  my Str $opcode = '';
  my Str $rest = '';
  if $tline ~~ /^\S/ { # we have a label
        $tline ~~ s/^(\S+)//;
       $label = ~$0;
  } else {
    #say "no label";
  }
  $tline ~~ s/^\s+//;
  if $tline ~~ /^[\w|\.]/ {
    $tline ~~ s/^(\S+)//;
    $opcode = ~$0;
  }
  $tline ~~ s/^\s+//;
  $rest = $tline;
  my $orig_rest = $rest;
  if %macro{$opcode.lc}.defined {
    format_listing(-1, '', $label, $opcode, $rest);
    expand_macro($label, $opcode.lc, $rest);
    next;
  }
  $rest ~~ s:g/ <wb>(\w+)<wb> /{
				my $word = $0;
				if %define{$word}.defined {
				  %define{$word}
				} else {
				  $word
				}
			       }/;
  return ($label, $opcode, $orig_rest, $rest);
}

sub
get_next_line {
  loop {
    if ! $input_line.defined {
      return (Str, Str, Str, Str);
    }
    my Str $line = $input_line();
    if ! $line.defined {
      return (Str, Str, Str, Str);
    }
    if $current_macro_def {
#say "Defining macro $current_macro_def: $line";
      if $line ~~ /^<ws>\.endm<wb>/ {
#say "Found endm";
	$current_macro_def = '';
      } else {
#say "Adding line to macro";
	%macro{$current_macro_def}.push($line);
      }
      simple_listing($line);
      next;
    }
    if $line ~~ m/^<ws>?[<[\#;]>.*]?$/ { # comments
      simple_listing($line);
      next;
    }
    if $line ~~ m/^<ws>\.macro<ws>(\S+)/ {
      simple_listing($line);
      $current_macro_def = ~$/[0];
      %macro{$current_macro_def} = [];
      next;
    }
    if $line ~~ m/^<ws>\.include<ws>(\S+)/ {
      simple_listing($line);
      include_file(~$/[0]);
      next;
    }
    if $line ~~ m/^<ws>  \.if <ws> / {
      if $ifdepth == $truedepth {
	# only in this case do we care about the value of the expression
	my $expr = $line;
	$expr ~~ s/^<ws> '.if' <ws>//;
	my $m = Assembler.subparse($expr,
				:actions(Assembler::Actions),
				:rule(<expression>));
	if ?+$m.made<value> {
	  ++$truedepth;
	}
      }
      ++$ifdepth;
      next;
    }
    if $line ~~ m/^<ws>\.else<wb>/ {
      if $ifdepth == $truedepth {
	--$truedepth;
      } else {
	if $ifdepth == $truedepth + 1 {
	  ++$truedepth;
	}
      }
      next;
    }
    if $line ~~ m/^<ws>\.endif<wb>/ {
      --$ifdepth;
      if $ifdepth < $truedepth {
	$truedepth = $ifdepth;
      }
      next;
    }
    if ($truedepth == $ifdepth) {
      my ($label, $opcode, $orig_rest, $rest) = parse_line($line);
      return ($line, $label, $opcode, $orig_rest, $rest);
    }
    else {
        simple_listing $line;
    }
  }
}

# Output

my $suppress_output = 1;
my $nolist = 0;

# listing

sub simple_listing(Str $line) {
  return if $suppress_output; # some variables below don't exist on earlier passes
  return if $nolist;
  printf "%4d                 %s\n", $line_number, $line;
}

sub error_listing(Str $msg) {
  return if $suppress_output; # some variables below don't exist on earlier passes
  return if $nolist;
  printf "                    %s\n", $msg;
}

sub format_listing(Int $pc, Str $code, Str $label, Str $opcode, Str $rest) {
  return if $suppress_output; # some variables below don't exist on earlier passes
  return if $nolist;
  my $code_str = $code;
  if $code.chars > %param<codewidth> {
    $code_str = substr($code, 0, 9) ~ '>';
  }
  my $pcformat = '';
  my $pc_str;
  if $pc >= 0 {
    $pcformat = ' ' x %param<pcwidth>
      - +@memspace[0]<pcwidth> ~
	'%0'
	  ~ sprintf('%d.%dx ', +@memspace[0]<pcwidth>, +@memspace[0]<pcwidth>)
	    ~ @memspace[0]<label>;
    $pc_str = (($pc < 0) ?? (' ' x (%param<pcwidth> + 2)) !! sprintf($pcformat, $pc));
  } else {
    $pc_str = ' ' x (%param<pcwidth> + 2);
  }
  my $fmt = ' %4d %s %-' ~ %param<codewidth>+1 ~ 's %8s %8s %s' ~ "\n";
  printf $fmt, $line_number, $pc_str, $code_str, $label, $opcode, $rest;
}

# S1 output

my %bytes;

my $s1outaddr = -2; # don't use -1
my $s1outcount = 0;
my $s1outstring = '';
my $s1checksum = 0;
my $s1_header = '';

my Str $s1file = '';

# Code to handle S1 format output files

sub putword($addr, $word) {
  %bytes{$addr} = $word +& 0x00ff;
  %bytes{$addr+1} = ($word +> 8) +& 0x00ff;
}

sub hexbyte($byte) {
  my $nybble2 = (($byte     ) +& 0x0f) + 0x30;
  $nybble2 += 7 if $nybble2 >= 0x3a;
  my $nybble1 = (($byte +> 4) +& 0x0f) + 0x30;
  $nybble1 += 7 if $nybble1 >= 0x3a;
  my $c1 = $nybble1.chr;
  my $c2 = $nybble2.chr;
  my $string = $c1 ~ $c2;
  return $string;
}

sub put_bytes($header, $count, $string, $checksum) {
  print $header;
  print hexbyte($count);
  print $string;
  my $tchecksum = $checksum +& 0x0ff;
  print hexbyte($tchecksum);
  print "\n";
}

sub write_s1_record() {
  if ($s1outaddr >= 0) {
    $s1checksum += $s1outcount;
    put_bytes($s1_header, $s1outcount+1, $s1outstring, +^$s1checksum);
    $s1outaddr = -2;
    $s1outcount = 0;
  }
}

sub write_s1byte($addr, $byte) {
  my $value = $byte +& 0xff;
  if ($addr != ($s1outaddr + 1)) {
    write_s1_record();
  }
  if ($s1outcount == 0) {
    if ($addr < 0x10000) {
      $s1_header = 'S1';
      $s1outstring = hexbyte($addr +> 8) ~ hexbyte($addr);
      $s1checksum = ($addr +> 8) + $addr;
      $s1outcount = 2;
    } elsif ($addr < 0x1000000) {
      $s1_header = 'S2';
      $s1outstring = hexbyte($addr +> 16) ~ hexbyte($addr +> 8) ~ hexbyte($addr);
      $s1checksum = ($addr +> 16) + ($addr +> 8) + $addr;
      $s1outcount = 3;
    } else {
      $s1_header = 'S3';
      $s1outstring = hexbyte($addr +> 24) ~ hexbyte($addr +> 16) ~ hexbyte($addr +> 8) ~ hexbyte($addr);
      $s1checksum = ($addr +> 24) + ($addr +> 16) + ($addr +> 8) + $addr;
      $s1outcount = 4;
    }
  }
  $s1outstring ~= hexbyte($byte);
  $s1checksum += $byte;
  ++$s1outcount;
  $s1outaddr = $addr;
  if ($s1outcount >= 18) {
    write_s1_record();
  }
}

sub write_s1($file) {
  my $*OUT = open($file, :w);
  for sort {$^a <=> $^b}, %bytes.keys -> $addr {
    write_s1byte(+$addr, %bytes{$addr});
  }
  write_s1_record(); # flush any remaining buffer
  say "S9030000FC";
}

sub assign_symbol(Str $labelfield, $value, $pass) {
  my $label = $labelfield.lc;
  $label ~~ s/\:$//;
  if ($label ~~ /^(\d\d?)$/ ) {
    if ($pass == 1) {
      @local_symbol[$0] = [] unless @local_symbol[$0].defined;
      @local_symbol[$0].push($pc);
    }
    ++@local_pointer[$0];
  } else {
    %symbol{$label} = {} unless %symbol{$label}.defined;
    %symbol{$label}<value> = +$value;
    %symbol{$label}<memspace> = @memspace[0]<id>;
    %symbol{$label}<pass> = $pass;
  }
}

# Here's where we define the assembler directives. They are ISA independent
# Note that the code is a set of anonymous subroutines, stored in the %directive hash.

my %constantsize = '.db' => 1,
                   '.dw' => 2,
		   '.dl' => 4;

%directive<.byte> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing($pc, '', $label, $opcode, $rest);
  assign_symbol($label, +$pc, $pass) if $label; ++$pc;
};

%directive<.word> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing($pc, '', $label, $opcode, $rest);
  assign_symbol($label, +$pc, $pass) if $label;
  $pc += 2;
};

%directive<.long> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing($pc, '', $label, $opcode, $rest);
  assign_symbol($label, +$pc, $pass) if $label;
  $pc += 4;
};

%directive<.list> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing(-1, '', $label, $opcode, $rest);
  $nolist--;
  $nolist = 0 if $nolist < 0;
};

%directive<.nolist> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing(-1, '', $label, $opcode, $rest);
  ++$nolist;
};

%directive<.device> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing(-1, '', $label, $opcode, $rest);
};

%directive<.listmac> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing(-1, '', $label, $opcode, $rest);
};

%directive<.set> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  my $m = Assembler.subparse($args,
			  :actions(Assembler::Actions),
			  :rule(<id>));
  my $symbol = ~$m[0];
  $args ~~ s/^<-[=]>* <ws>? '=' <ws>? //;
  $m = Assembler.subparse($args,
		       :actions(Assembler::Actions),
		       :rule(<expression>));
  my $value = +$m.made<value>;
  format_listing(-1, '', $label, $opcode, $rest);
  assign_symbol($symbol, +$m.made, $pass);
};

%directive<.def> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  return unless $pass == 1; # not much point continuing; the name has already been substituted!
  my $args = $rest;
  chomp $args;
  my $m = Assembler.subparse($args,
			  :actions(Assembler::Actions),
			  :rule(<id>));
  my $symbol = ~$m[0];
  $args = $args.substr(+$m.to); # remove identifier
  $args ~~ s/ ^ <ws> \= <ws> //;
  $m = Assembler.subparse($args,
		       :actions(Assembler::Actions),
		       :rule(<id>));
  my $value = ~$m[0];
  simple_listing ".def $symbol = $value";
  %define{$symbol} = $value;
};

%directive<.param> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  my $m = Assembler.subparse($args,
			  :actions(Assembler::Actions),
			  :rule(<id>));
  my $param = ~$m[0];
  $args = $args.substr(+$m.to); # remove identifier
  $args ~~ s/ ^ <ws>? \= <ws>? //;
  $m = Assembler.subparse($args,
		       :actions(Assembler::Actions),
		       :rule(<expression>));
  my $value = +$m.made<value>;
  simple_listing ".param $param = $value";
  %param{$param} = $value;
};

%directive<.equ> = %directive<.set>;

%directive<.db> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $size = %constantsize{$opcode};
  my $format = sprintf("\%\%0\%dx", $size*2);
  my $args = $rest;
  assign_symbol($label, $pc, $pass) if $label;
  loop {
    my $m = Assembler.subparse($args,
			    :actions(Assembler::Actions),
			    :rule(<expression>));
    if ?$m {
      my $value = $m.made<value>;
      format_listing($pc, sprintf($format, +$value), $label, $opcode, $rest);
      putword($pc*2, $value); # FIX
      if ($size == 4) {
        putword($pc*2 + 2, $value +> 16);
      }
      $pc += $size div 2;
      $args = $args.substr(+$m.to);
      $m = $args ~~ m/ ',' /;
      last unless ?$m;
      $args = $args.substr(+$m.to); 
    } else {
      error_listing '*** unknown value';
      format_listing($pc, '', $label, $opcode, $rest);
      last;
    }
  }
};

%directive<.dw> = %directive<.db>;

%directive<.dl> = %directive<.db>;

%directive<.end> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  say ".end" unless $nolist;
};

%directive<.exit> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  simple_listing ".exit";
};

%directive<.org> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  say ".org" unless $nolist;
  my $m = Assembler.subparse($rest,
			  :actions(Assembler::Actions),
			  :rule(<expression>));
  $pc = +$m.made<value>;
};

%directive<.pushmem> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $m = Assembler.subparse($rest,
			  :actions(Assembler::Actions),
			  :rule(<id>));
  my $arg = ~$m[0];
  if ! %memspace{$arg}.defined {
    %memspace{$arg} = {};
    %memspace{$arg}<pc> = 0.Int;
    %memspace{$arg}<id> = $arg;
  }
  @memspace.unshift(%memspace{$arg});
  $pc := @memspace[0]<pc>;
};

%directive<.popmem> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  shift @memspace;
  $pc := @memspace[0]<pc>;
};

%directive<.defmem> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  my $m = Assembler.subparse($args,
			  :actions(Assembler::Actions),
			  :rule(<id>));
  my $symbol = ~$m[0];
  $args ~~ s/^<-[=]>* <ws>? '=' <ws>? //;
  $m = Assembler.subparse($args,
		       :actions(Assembler::Actions),
		       :rule(<expression>));
  if ?$m {
    my $value = +$m.made<value>;
    format_listing(-1, '', $label, $opcode, $rest);
    @memspace[0]{$symbol} = $value;
  } else {
    $m = Assembler.subparse($args,
  		       :actions(Assembler::Actions),
  		       :rule(<stringexpression>));
    if ?$m {
      my $value = ~$m.made;
      format_listing -1, '', $label, $opcode, $rest;
      @memspace[0]{$symbol} = $value;
    } else {
      simple_listing 'Unrecognised value field';
      format_listing -1, '', $label, $opcode, $rest;
    }
  }
};

%directive<.dump> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  my @args = $rest.split(',');
  for @args -> $arg {
    if $arg eq 'symbols' {
      print_symbols();
    }
  }
};

%directive<.isa> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  return unless $pass == 1;
  my $args = $rest;
  my $m = Assembler.subparse($args,
                          :actions(Assembler::Actions),
                          :rule(<id>));
  if ?$m {
    $isa = ~$m[0];
  } else {
    say "Invalid format for .isa directive";
  }
}

# .instruction inh     clt    0x94d8

%directive<.instruction> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  return unless $pass == 1;
  my $args = $rest;
  my $m = Assembler.subparse($args,
			  :actions(Assembler::Actions),
			  :rule(<id>));
  my $instr_type = ~$m[0];
  $args ~~ s/^ <.ws>? \S+ <.ws>? //;
  $m = Assembler.subparse($args,
                       :actions(Assembler::Actions),
		       :rule(<id>));
  my $opc = ~$m[0];
  $args ~~ s/^ <.ws>? \S+ <.ws>? //;
  $m = Assembler.subparse($args,
		       :actions(Assembler::Actions),
		       :rule(<expression>));
  my $value = +$m.made<value>;
  format_listing(-1, '', $label, $opcode, $rest);
#say ".instruction: $isa $instr_type $opc $value";
  %instructions{$isa}{$instr_type}<hash>{$opc} = $value;
};

%directive<.assemble> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  #say %instructions;
  for %instructions{$isa}.keys -> $key {
    my $arrayname = %instructions{$isa}{$key}<array>;
    my $vals = %instructions{$isa}{$key}<hash>.keys.join(' ');
    #say "\@$arrayname = <$vals>";
    EVAL "\@$arrayname = <$vals>";
  }
  $instructionset = %instructionset{$isa};
}

sub assemble_instruction($label, $opcode, $orig_rest, $rest) {
  my $words = ();
  my $code = '';
  my $instruction_length = 0;
  if $opcode {
    my $m = $instructionset.subparse("$opcode $rest ",
			    :actions(Assembler::Actions),
			    :rule(<instruction>));
    if $m {
      $words = $m.made;
      my $nybbles = ((@memspace[0]<width> + 3) / 4);
      my $format = '%0' ~ sprintf("%d.%dx ", $nybbles, $nybbles);
#say $words.perl;
      for ^+$words -> $index {
        $code ~= sprintf($format, $words[$index]);
	putword(($pc+$instruction_length)*2, $words[$index]);
	$instruction_length++;
      }
      $code ~~ s/ ' ' $//; # delete trailing space
    } else {
      error_listing "*** Unrecognised instruction format";
    }
  }
  format_listing($pc, $code, $label, $opcode, $orig_rest);
  $pc += $instruction_length;
}

my @files = ();

sub do_pass(Int $pass_number) {
  $suppress_output = ($pass_number == 2) ?? 0 !! 1;
  $suppress_output = 0;
  $ifdepth = 0;
  $truedepth = 0;
  $current_macro_def = '';
  setup_local_pointer();
# reset program counters
  for %memspace.keys -> $space {
    %memspace{$space}<pc> = 0;
  }
  @memspace = ({'pc' => 0.Int});
  $pc := @memspace[0]{'pc'};

# include the filenames in reverse order so the first gets opened first
# and then chains through to the second and so on
  for 0 .. +@files-1 ->$fileindex {
      include_file(@files[$fileindex]);
  }
  loop {
    my (Str $line, Str $label, Str $opcode, Str $orig_rest, Str $rest) = get_next_line();
    if ($line.defined) {
      if $opcode.defined {
        $rest = '' unless $rest.defined;
        $opcode = '' unless $opcode.defined;
        $opcode = $opcode.lc;
        if %directive{$opcode}.defined {
	  %directive{$opcode}($label, $opcode, $rest, $pass_number);
        } else {
	  assign_symbol($label, +$pc, $pass_number) if $label;
	  assemble_instruction($label, $opcode, $orig_rest, ~$rest);
        }
      } else {
        assign_symbol($label, $pc, $pass_number) if $label;
        format_listing($pc, '', $label, '', '');
      }
    } else {
      return(0);
    }
  }
}

sub print_symbols () {
  say "";
  say "Symbol Table:";
  say "=============";
  for (sort keys %symbol) -> $symbol {
    if $symbol ~~ /^_/ {
      # ignore symbols starting with _
    } else {
      my $pcformat = '';
      my $pc_str;
      my $pc = %symbol{$symbol}<value>;
      my $memspace = %symbol{$symbol}<memspace>;
      $pcformat = ' ' x %param<pcwidth>
	- +%memspace{$memspace}<pcwidth> ~
	  '%0'
	    ~ sprintf('%d.%dx ', +%memspace{$memspace}<pcwidth>, +%memspace{$memspace}<pcwidth>)
	      ~ %memspace{$memspace}<label>;
      $pc_str = sprintf($pcformat, $pc);
      say sprintf "%s %s", $pc_str, $symbol;
    }
  }
  say "";
  say "Definitions:";
  say "===========";
  for (%define.keys.sort) -> $symbol {
    if $symbol ~~ /^_/ {
      # ignore symbols starting with _
    } else {
      my $value = %define{$symbol};
      say sprintf "%s %s", $symbol, $value;
    }
  }
}

# START HERE
for @*ARGS -> $arg {
  if $arg ~~ /^\-s/ {
    $s1file = ~$arg;
    $s1file ~~ s/^\-s//;
    next;
  }
  unshift @files, $arg; # last file specified will be first in list
}

{
  my $*OUT = open '/dev/null', :w;
  do_pass(1+0);
}

do_pass(+2);

#say "Assembly completed!!!";
print_symbols();

if $s1file {
  write_s1($s1file);
}
