#!/usr/local/bin/perl6

use v6;

my %param = (codewidth => 9);
%param<pcwidth> = 8;

my %directive = ();

my @local_pointer = ();
my @local_symbol = ();

my %memspace;
my Int $pc;
my @memspace = ({'pc' => 0.Int});

sub setup_local_pointer() {
    for 0..99 -> $index {
	@local_pointer[$index] = -1;
    }
}

sub setup_local() {
    for 0..99 -> $index {
	@local_symbol[$index] = [];
    }
    # setup_local_pointer() is called in do_pass
}

setup_local();

my %symbol = ();

my $isa = '';
my %instructions;

# This should be a macro!
sub make_hash(Str $isa, Str $instr) {
  # %instructions{$isa}{$instr} = hash => {}, array => "{$isa}_instr_{$instr}";
  %instructions{$isa}{$instr}<array> = "{$isa}_instr_{$instr}";
  #%instructions{$isa}{$instr}<hash> = ();
}

# Variables required for AVR

my @avr_instr_inh;      make_hash('avr', 'inh');
my @avr_instr_rr;       make_hash('avr', 'rr');
my @avr_instr_ww;       make_hash('avr', 'ww');
my @avr_instr_rr3;      make_hash('avr', 'rr3');
my @avr_instr_rr4;      make_hash('avr', 'rr4');
my @avr_instr_r2;       make_hash('avr', 'r2');
my @avr_instr_r;        make_hash('avr', 'r');
my @avr_instr_r_reg;    make_hash('avr', 'r_reg');
my @avr_instr_iw;       make_hash('avr', 'iw');
my @avr_instr_ir;       make_hash('avr', 'ir');
my @avr_instr_i6r;      make_hash('avr', 'i6r');
my @avr_instr_out;      make_hash('avr', 'out');
my @avr_instr_irc;      make_hash('avr', 'irc');
my @avr_instr_sreg;     make_hash('avr', 'sreg');
my @avr_instr_tbit;     make_hash('avr', 'tbit');
my @avr_instr_brb;      make_hash('avr', 'brb');
my @avr_instr_branch;   make_hash('avr', 'branch');
my @avr_instr_lbranch;  make_hash('avr', 'lbranch');
my @avr_instr_long;     make_hash('avr', 'long');
my @avr_instr_lds;      make_hash('avr', 'lds');
my @avr_instr_sts;      make_hash('avr', 'sts');
my @avr_instr_bio;      make_hash('avr', 'bio');
my @avr_instr_i4;       make_hash('avr', 'i4');
my @avr_instr_rx;       make_hash('avr', 'rx');
my @avr_instr_xr;       make_hash('avr', 'xr');
my @avr_instr_rxplus;   make_hash('avr', 'rxplus');
my @avr_instr_xrplus;   make_hash('avr', 'xrplus');
my @avr_instr_rxminus;  make_hash('avr', 'rxminus');
my @avr_instr_xrminus;  make_hash('avr', 'xrminus');
my @avr_instr_ry;       make_hash('avr', 'ry');
my @avr_instr_yr;       make_hash('avr', 'yr');
my @avr_instr_ryplus;   make_hash('avr', 'ryplus');
my @avr_instr_yrplus;   make_hash('avr', 'yrplus');
my @avr_instr_ryminus;  make_hash('avr', 'ryminus');
my @avr_instr_yrminus;  make_hash('avr', 'yrminus');
my @avr_instr_ryq;      make_hash('avr', 'ryq');
my @avr_instr_yrq;      make_hash('avr', 'yrq');
my @avr_instr_rz;       make_hash('avr', 'rz');
my @avr_instr_stzr;     make_hash('avr', 'stzr');
my @avr_instr_rzplus;   make_hash('avr', 'rzplus');
my @avr_instr_zrplus;   make_hash('avr', 'zrplus');
my @avr_instr_rzminus;  make_hash('avr', 'rzminus');
my @avr_instr_zrminus;  make_hash('avr', 'zrminus');
my @avr_instr_rzq;      make_hash('avr', 'rzq');
my @avr_instr_zrq;      make_hash('avr', 'zrq');
my @avr_instr_z;        make_hash('avr', 'z');
my @avr_instr_zr;       make_hash('avr', 'zr');
my @avr_instr_zplus;    make_hash('avr', 'zplus');
my @avr_instr_noz;      make_hash('avr', 'noz');

# Variables required for PIC

my @pic18_instr_inh;      make_hash('pic', 'inh');
my @pic18_instr_bytefda;  make_hash('pic', 'bytefda');
my @pic18_instr_bytefa;   make_hash('pic', 'bytefa');
my @pic18_instr_byteff;   make_hash('pic', 'byteff');
my @pic18_instr_bit;      make_hash('pic', 'bit');
my @pic18_instr_branch;   make_hash('pic', 'branch');
my @pic18_instr_lbranch;  make_hash('pic', 'lbranch');
my @pic18_instr_call;     make_hash('pic', 'call');
my @pic18_instr_ret;      make_hash('pic', 'ret');
my @pic18_instr_lit;      make_hash('pic', 'lit');
my @pic18_instr_bsr;      make_hash('pic', 'bsr');
my @pic18_instr_tblrd;    make_hash('pic', 'tblrd');

# Variables required for mc6809

my @mc6809_instr_inh;   make_hash('mc6809', 'inh');
my @mc6809_instr_imm8;  make_hash('mc6809', 'imm8');
my @mc6809_instr_imm16; make_hash('mc6809', 'imm16');
my @mc6809_instr_die;   make_hash('mc6809', 'die');
my @mc6809_instr_br;    make_hash('mc6809', 'br');
my @mc6809_instr_lbr;   make_hash('mc6809', 'lbr');
my @mc6809_instr_tfr;   make_hash('mc6809', 'tfr');
my @mc6809_instr_psh;   make_hash('mc6809', 'psh');

# Variables required for ARM

my @arm_instr_inh;      make_hash('arm', 'inh');
my @arm_instr_mul;      make_hash('arm', 'mul');
my @arm_instr_mla;      make_hash('arm', 'mla');
my @arm_instr_mull;     make_hash('arm', 'mull');
my @arm_instr_sds;      make_hash('arm', 'sds');
my @arm_instr_brx;      make_hash('arm', 'brx');
my @arm_instr_hdt;      make_hash('arm', 'hdt');
my @arm_instr_sdt;      make_hash('arm', 'sdt');

grammar Assembler {

# basic rules for expressions

    token identifier              { <wb> ( <[a..z A..Z _ $]> <[a..z A..Z 0..9 _ \.]>* ) <wb>   }
    token localref                { (\d\d?) ( <[fb]> )                                         }
    token plusminus               { < + - >?                                                   }
    proto token number            { <*>                                                        }
    token number:sym<decimal>     { <plusminus> ( <[0..9]>+ )                                  }
    token number:sym<binary>      { '0' <[bB]> <[01]>+                                         }
    token number:sym<octal>       { '0' <[oO]> <[0..7]>+                                       }
    token number:sym<hex>         { '0' <[Xx]> <[0..9 a..f A..F]>+                             }
    token number:sym<hex2>        {     '$'   (<[0..9 a..f A..F]>+)                            }
    proto rule term               { <*>                                                        }
    rule term:sym<localref>       { <localref>                                                 }
    rule term:sym<number>         { <number>                                                   }
    rule term:sym<funcall>        { $<identifier>=(low|LOW|high|HIGH) '(' <expression> ')'     }
    rule term:sym<identifier>     { <identifier>                                               }
    rule term:sym<pexpr>          {'(' <expression> ')'                                        }
    token addoper                 { '+' | '-'                                                  }
    token muloper                 { '*' | '/' | '%' | '<<' | '>>'                              }
    rule mulexpr                  { <term> [ <muloper> <term> ]*                               }
    rule expression               { [ <mulexpr> [ <addoper> <mulexpr> ]* ]                     }
    proto token string            { <*>                                                        }
    token string:sym<singlequote> { \' ( <[a..z A..Z 0..9 <ws>]>* ) \'                         } # FIXME
    rule stringexpression         { <string>                                                   }
    proto regex instruction       { <*>                                                        }
    token comma                   { <.ws>? ',' <.ws>?                                          }

# Rules for AVR

  rule avr_bit                      { <expression>                                                                             }
  token avr_reg                     { <[rR]> ( \d+ ) [ '+' (\d+) ]?                                                            }
  token avr_regpair                 { <[rR]> ( \d+ ) ':' <[rR]> ( \d+ )                                                        }
  regex instruction:sym<avr_rr>      { $<mnemonic>=@avr_instr_rr      <avr_reg> ',' <avr_reg> <ws>                              }
  regex instruction:sym<avr_ww1>     { $<mnemonic>=@avr_instr_ww      <avr_regpair> ',' <avr_regpair> <ws>                      }
  regex instruction:sym<avr_ww2>     { $<mnemonic>=@avr_instr_ww      <avr_reg> ',' <avr_reg> <ws>                              }
  regex instruction:sym<avr_rr3>     { $<mnemonic>=@avr_instr_rr3     <avr_reg> ',' <avr_reg> <ws>                              }
  regex instruction:sym<avr_rr4>     { $<mnemonic>=@avr_instr_rr4     <avr_reg> ',' <avr_reg> <.ws>                             }
  regex instruction:sym<avr_r2>      { $<mnemonic>=@avr_instr_r2      <avr_reg> <ws>                                            }
  regex instruction:sym<avr_r>       { $<mnemonic>=@avr_instr_r       <avr_reg> <ws>                                                }
  regex instruction:sym<avr_inh>     { $<mnemonic>=@avr_instr_inh     <ws>                                                      }
  regex instruction:sym<avr_iw>      { $<mnemonic>=@avr_instr_iw      <ws> <avr_regpair> ',' <expression> <ws>                  }
  regex instruction:sym<avr_iw2>     { $<mnemonic>=@avr_instr_iw      <ws> <avr_reg> ',' <expression> <ws>                      }
  regex instruction:sym<avr_ir>      { $<mnemonic>=@avr_instr_ir      <ws> <avr_reg> ',' <expression> <ws>                      }
  regex instruction:sym<avr_irc>     { $<mnemonic>=@avr_instr_irc     <ws> <avr_reg> ',' <expression> <ws>                      }
  regex instruction:sym<avr_sreg>    { $<mnemonic>=@avr_instr_sreg    <ws> <avr_bit> <ws>                                       }
  regex instruction:sym<avr_tbit>    { $<mnemonic>=@avr_instr_tbit    <ws> <avr_reg> ',' <avr_bit> <ws>                         }
  regex instruction:sym<avr_brb>     { $<mnemonic>=@avr_instr_brb     <ws> <avr_bit> ',' <expression> <ws>                      }
  regex instruction:sym<avr_branch>  { $<mnemonic>=@avr_instr_branch  <ws> <expression> <ws>                                    }
  regex instruction:sym<avr_lbranch> { $<mnemonic>=@avr_instr_lbranch <ws> <expression> <ws>                                    }
  regex instruction:sym<avr_long>    { $<mnemonic>=@avr_instr_long    <ws> <expression> <ws>                                    }
  regex instruction:sym<avr_lds>     { $<mnemonic>=@avr_instr_lds     <ws> <avr_reg> ',' <expression> <ws>                      }
  regex instruction:sym<avr_sts>     { $<mnemonic>=@avr_instr_sts     <ws> <expression> ',' <avr_reg> <ws>                      }
  regex instruction:sym<avr_bio>     { $<mnemonic>=@avr_instr_bio     <ws> <expression> ',' <avr_bit> <ws>                      }
  regex instruction:sym<avr_i4>      { $<mnemonic>=@avr_instr_i4      <ws> <expression> <ws>                                    }
  regex instruction:sym<avr_rx>      { $<mnemonic>=@avr_instr_rx      <ws> <avr_reg> ',' <[xX]> <!before '+'> <ws>              }
  regex instruction:sym<avr_xr>      { $<mnemonic>=@avr_instr_xr      <ws> <[xX]> ',' <avr_reg> <ws>                            }
  regex instruction:sym<avr_rxplus>  { $<mnemonic>=@avr_instr_rxplus  <ws> <avr_reg> ',' <[xX]>'+' <ws>                         }
  regex instruction:sym<avr_xrplus>  { $<mnemonic>=@avr_instr_xrplus  <ws> <[xX]>'+' ',' <avr_reg> <ws>                         }
  regex instruction:sym<avr_rxminus> { $<mnemonic>=@avr_instr_rxminus <ws> <avr_reg> ',' '-'<[xX]> <ws>                         }
  regex instruction:sym<avr_xrminus> { $<mnemonic>=@avr_instr_xrminus <ws> '-'<[xX]> ',' <avr_reg> <ws>                         }
  regex instruction:sym<avr_ry>      { $<mnemonic>=@avr_instr_ry      <ws> <avr_reg> ',' <[yY]> <!before '+'> <ws>              }
  regex instruction:sym<avr_yr>      { $<mnemonic>=@avr_instr_yr      <ws> <[yY]> ',' <avr_reg> <ws>                            }
  regex instruction:sym<avr_ryplus>  { $<mnemonic>=@avr_instr_ryplus  <ws> <avr_reg> ',' <[yY]>'+' <!before <expression> > <ws> }
  regex instruction:sym<avr_yrplus>  { $<mnemonic>=@avr_instr_yrplus  <ws> <[yY]>'+' ',' <avr_reg> <ws>                         }
  regex instruction:sym<avr_ryminus> { $<mnemonic>=@avr_instr_ryminus <ws> <avr_reg> ',' '-'<[yY]> <ws>                         }
  regex instruction:sym<avr_yrminus> { $<mnemonic>=@avr_instr_yrminus <ws> '-'<[yY]> ',' <avr_reg> <ws>                         }
  regex instruction:sym<avr_ryq>     { $<mnemonic>=@avr_instr_ryq     <ws> <avr_reg> ',' <[yY]> '+' <expression> <ws>           }
  regex instruction:sym<avr_yrq>     { $<mnemonic>=@avr_instr_yrq     <ws> <[yY]> '+' <expression> ',' <avr_reg> <ws>           }
  regex instruction:sym<avr_rz>      { $<mnemonic>=@avr_instr_rz      <ws> <avr_reg> ',' <[zZ]> <!before '+' > <ws>             }
  regex instruction:sym<avr_stzr>    { $<mnemonic>=@avr_instr_stzr    <ws> <[zZ]> ',' <avr_reg> <ws>                            }
  regex instruction:sym<avr_rzplus>  { $<mnemonic>=@avr_instr_rzplus  <ws> <avr_reg> ',' <[zZ]>'+' <ws>                         }
  regex instruction:sym<avr_zrplus>  { $<mnemonic>=@avr_instr_zrplus  <ws> <[zZ]>'+' ',' <avr_reg> <ws>                         }
  regex instruction:sym<avr_rzminus> { $<mnemonic>=@avr_instr_rzminus <ws> <avr_reg> ',' '-'<[zZ]> <ws>                         }
  regex instruction:sym<avr_zrminus> { $<mnemonic>=@avr_instr_zrminus <ws> '-'<[zZ]> ',' <avr_reg> <ws>                         }
  regex instruction:sym<avr_rzq>     { $<mnemonic>=@avr_instr_rzq     <ws> <avr_reg> ',' <[zZ]> '+' <expression> <ws>           }
  regex instruction:sym<avr_zrq>     { $<mnemonic>=@avr_instr_zrq     <ws> <[zZ]> '+' <expression> ',' <avr_reg> <ws>           }
  regex instruction:sym<avr_zr>      { $<mnemonic>=@avr_instr_zr      <ws> <[zZ]> ',' <avr_reg> <ws>                            }
  regex instruction:sym<avr_zplus>   { $<mnemonic>=@avr_instr_zplus   <ws> <avr_reg> ',' <[zZ]>'+' <ws>                         }
  regex instruction:sym<avr_noz>     { $<mnemonic>=@avr_instr_noz     <ws>                                                      }
  regex instruction:sym<avr_i6r>     { $<mnemonic>=@avr_instr_i6r     <ws> <avr_reg> ',' <expression> <ws>                      }
  regex instruction:sym<avr_out>     { $<mnemonic>=@avr_instr_out     <ws> <expression> ',' <avr_reg> <ws>                      }

# Rules for PIC

  token pic18_a                       { <expression>                                                                             } 
  token pic18_d                       { <expression>                                                                             } 
  token pic18_f                       { <expression>                                                                             } 
  token pic18_bit                     { <expression>                                                                             } 
  regex instruction:sym<pic18_inh>     { $<mnemonic>=@pic18_instr_inh     <.ws>                                                     }
  regex instruction:sym<pic18_bytefda> { $<mnemonic>=@pic18_instr_bytefda <.ws> <pic18_f> ',' <pic18_d> ',' <pic18_a> <ws>                }
  regex instruction:sym<pic18_bytefa>  { $<mnemonic>=@pic18_instr_bytefa  <.ws> <pic18_f> ',' <pic18_a> <ws>                            }
  regex instruction:sym<pic18_byteff>  { $<mnemonic>=@pic18_instr_byteff  <.ws> <expression> ',' <expression> <ws>                  }
  regex instruction:sym<pic18_bitm>    { $<mnemonic>=@pic18_instr_bit     <.ws> <pic18_f> ',' <pic18_bit> ',' <pic18_a> <ws>              }
  regex instruction:sym<pic18_branch>  { $<mnemonic>=@pic18_instr_branch  <.ws> <expression>                                        }
  regex instruction:sym<pic18_lbranch> { $<mnemonic>=@pic18_instr_lbranch <.ws> <expression>                                        }
  regex instruction:sym<pic18_call>    { $<mnemonic>=@pic18_instr_call    <.ws> <expression> [ ',' <expression> ] ?                 }
  regex instruction:sym<pic18_ret>     { $<mnemonic>=@pic18_instr_ret     <.ws> <expression> ?                                      }
  regex instruction:sym<pic18_lit>     { $<mnemonic>=@pic18_instr_lit     <.ws> <expression>                                        }
  regex instruction:sym<pic18_bsr>     { $<mnemonic>=@pic18_instr_bsr     <.ws> <expression>                                        }
  regex instruction:sym<pic18_tblrd>   { $<mnemonic>=@pic18_instr_tblrd   <.ws> ('*'|'*+'|'*-'|'+*')                                }

# Rules for mc6809

  token mc6809_acc                    { < a b >                                                                                  }
  token mc6809_acc16                  { 'd'                                                                                      }
  token mc6809_reg16                  { < x y u s >                                                                              }
  token mc6809_anyreg                 { < a b cc dp x y u s d pc >                                                               }
  proto regex mc6809_idx              { <*>                                                                                      }
  regex mc6809_idx:sym<off>            { <expression> ',' <mc6809_reg16>                                                          }
  regex mc6809_idx:sym<accoff>         { < a b d > ',' <mc6809_reg16>                                                             }
  regex mc6809_idx:sym<postinc>        { ',' <mc6809_reg16> ('+' ** 0..2)                                                         }
  regex mc6809_idx:sym<predec>         { ',' ('-' ** 1..2) <mc6809_reg16>                                                         }
  regex mc6809_idx:sym<pcrel>          { <expression> ',pcr'                                                                      }
  regex instruction:sym<mc6809_inh>   { $<mnemonic>=@mc6809_instr_inh  <.ws>                                                     }
  regex instruction:sym<mc6809_imm8>  { $<mnemonic>=@mc6809_instr_imm8 <.ws> '#' <expression>                                    }
  regex instruction:sym<mc6809_imm16> { $<mnemonic>=@mc6809_instr_imm16 <.ws> '#' <expression>                                   }
  regex instruction:sym<mc6809_dir>   { $<mnemonic>=@mc6809_instr_die <.ws> '<' <expression> <!before ',' >                      }
  regex instruction:sym<mc6809_ind1>  { $<mnemonic>=@mc6809_instr_die <.ws> <mc6809_idx>                                         }
  regex instruction:sym<mc6809_ind2>  { $<mnemonic>=@mc6809_instr_die <.ws> '[' <mc6809_idx> ']'                                 }
  regex instruction:sym<mc6809_ind3>  { $<mnemonic>=@mc6809_instr_die <.ws> '[' <expression> ']'                                 }
  regex instruction:sym<mc6809_ext>   { $<mnemonic>=@mc6809_instr_die <.ws> <expression> <!before ',' >                          }
  regex instruction:sym<mc6809_br>    { $<mnemonic>=@mc6809_instr_br  <.ws> <expression>                                         }
  regex instruction:sym<mc6809_lbr>   { $<mnemonic>=@mc6809_instr_lbr <.ws> <expression>                                         }
  regex instruction:sym<mc6809_tfr>   { $<mnemonic>=@mc6809_instr_tfr <.ws> <mc6809_anyreg> <.ws>? ',' <.ws>? <mc6809_anyreg>    }
  regex instruction:sym<mc6809_psh>   { $<mnemonic>=@mc6809_instr_psh <.ws> <mc6809_anyreg>+ % ','                               }

# Rules for ARM

  token arm_reg                       { <[rR]> ( \d+ ) [ '+' (\d+) ]?                                                            }
  token arm_cond                      { < eq ne cs cc mi pl vs vc hi ls ge lt gt le al >?                                        }
  token arm_setcond                   { 's'?                                                                                     }
  token arm_byte                      { 'b'?                                                                                     }
  proto regex arm_shift               { <*>                                                                                      }
  regex arm_shift:sym<imm>            { < lsl ror lsr asr > '#' <expression>                                                     }
  regex arm_shift:sym<reg>            { < lsl ror lsr asr > <arm_reg>                                                            }
  regex arm_shift:sym<rrx>            { 'rrx'                                                                                    }
  proto regex arm_hdtaddr             { <*>                                                                                      }
  regex arm_hdtaddr:sym<expr>         { <expression>                                                                             }
  regex arm_hdtaddr:sym<reg>          { '[' <arm_reg> ']' <!before <comma> >                                                     }
  regex arm_hdtaddr:sym<preimm>       { '[' <arm_reg> <comma> '#' <expression> ']' ('!'?)                                        }
  regex arm_hdtaddr:sym<preind>       { '[' <arm_reg> <comma> <plusminus> <arm_reg> ']' ('!'?)                                   }
  regex arm_hdtaddr:sym<postimm>      { '[' <arm_reg> ']' <comma> '#' <expression>                                               }
  regex arm_hdtaddr:sym<postind>      { '[' <arm_reg> ']' <comma>  <plusminus> <arm_reg>                                         }
  proto regex arm_sdtaddr             { <*>                                                                                      }
  regex arm_sdtaddr:sym<expr>         { <expression>                                                                             }
  regex arm_sdtaddr:sym<reg>          { '[' <arm_reg> ']' <!before <comma> >                                                     }
  regex arm_sdtaddr:sym<preimm>       { '[' <arm_reg> <comma> '#' <expression> ']' ('!'?)                                        }
  regex arm_sdtaddr:sym<preind>       { '[' <arm_reg> <comma> <plusminus> <arm_reg> ( <comma> <expression> )? ']' ('!'?)         }
  regex arm_sdtaddr:sym<postimm>      { '[' <arm_reg> ']' <comma> '#' <expression>                                               }
  regex arm_sdtaddr:sym<postind>      { '[' <arm_reg> ']' <comma>  <plusminus> <arm_reg> ( <comma> <expression> )?               }
  regex arm_sbh                       { < h sb sh >                                                                              }
  regex arm_b                         { 'b'?                                                                                     }
  regex arm_t                         { 't'?                                                                                     }
  regex instruction:sym<arm_inh>      { $<mnemonic>=@arm_instr_inh  <arm_cond>               <.ws>                               }
  regex instruction:sym<arm_mul>      { $<mnemonic>=@arm_instr_mul  <arm_cond> <arm_setcond> <.ws> <arm_reg> ** 3..3 % <comma>   }
  regex instruction:sym<arm_mla>      { $<mnemonic>=@arm_instr_mla  <arm_cond> <arm_setcond> <.ws> <arm_reg> ** 4..4 % <comma>   }
  regex instruction:sym<arm_mull>     { $<mnemonic>=@arm_instr_mull <arm_cond> <arm_setcond> <.ws> <arm_reg> ** 4..4 % <comma>   }
  regex instruction:sym<arm_sds>      { $<mnemonic>=@arm_instr_sds  <arm_cond> <arm_byte>    <.ws> <arm_reg> ** 2 % <comma> <comma> '[' <arm_reg> ']' }
  regex instruction:sym<arm_brx>      { $<mnemonic>=@arm_instr_brx  <arm_cond>               <.ws> <arm_reg>                     }
  regex instruction:sym<arm_hdt>      { $<mnemonic>=@arm_instr_hdt  <arm_cond> <arm_sbh>     <.ws> <arm_reg> <comma> <arm_hdtaddr>       }
  regex instruction:sym<arm_sdt>      { $<mnemonic>=@arm_instr_sdt  <arm_cond> <arm_b> <arm_t> <.ws> <arm_reg> <comma> <arm_sdtaddr>       }

}

sub mkexp {
  my ($value, $def) = @_;
  #say "Making expression from $value, $def";
  return {value => $value, def => $def};
}

class Assembler::Actions {
  method localref($/) {
    my $value;
    my $def = 1; # assume backwards ref
    my $index = +$/[0];
    my $index2 = @local_pointer[$index];
    if ~$/[1] eq 'f' {
      ++$index2;
      $def = 0;
    }
#say "In method local_ref: index is $index ($index2)";
    if $index2 < 0 {
      $value = 0; # Should be error
    } else {
      $value = @local_symbol[$index][$index2];
    }
    make mkexp($value, $def);
  }
  method number:sym<binary>($/)   { make :2(~$/); }
  method number:sym<octal>($/)    { make :8(~$/); }
  method number:sym<hex>($/)      { make :16(~$/); }
  method number:sym<hex2>($/)     { make :16(~$/[0]); }
  method number:sym<decimal>($/)  { make $/<plusminus>.ast * :10(~$/[0]); }
  method term:sym<identifier>($/) {
    my $sym = ~$/<identifier>;
    my $lcsym = $sym.lc;
    if %symbol{$lcsym}.defined {
      my $val = %symbol{$sym.lc}<value>;
      make mkexp($val, 1);
    } else {
      error_listing "*** Undefined symbol \"$sym\"";
      make mkexp(0, 0);
    }
  }
  method term:sym<number>($/)     { make mkexp($/<number>.ast, 1); }
  method term:sym<expression>($/) { make $/<expression>.ast; }
  method term:sym<localref>($/)   { make $/<localref>.ast; }
  method term:sym<pexpr>($/)      { make $/<expression>.ast; }
  method term:sym<funcall>($/)    {
    my $def = $/<expression>.ast<def>;
    if $/<identifier>.lc eq 'low' {
      make mkexp($/<expression>.ast<value> +& 0xff, $def);
    }
    if $/<identifier>.lc eq 'high' {
      make mkexp( ($/<expression>.ast<value> +> 8) +& 0xff, $def);
    }
  }
  method expression($/) {
    my $value = $/<mulexpr>[0].ast<value>;
    my $def   = $/<mulexpr>[0].ast<def>;
    if ?$/<addoper> {
      for 0 .. (+$<addoper> - 1) -> $index {
	my $oper = ~$/<addoper>[$index];
	if $oper ~~ '+' {
	  $value += $/<mulexpr>[$index + 1].ast<value>;
	} else {
	  $value -= $/<mulexpr>[$index + 1].ast<value>;
	}
        $def &= $/<mulexpr>[$index + 1].ast<def>;
      }
    }
    make mkexp($value, $def);
  }
  method mulexpr($/) {
    my $value = +$/<term>[0].ast<value>;
    my $def   = +$/<term>[0].ast<def>;
    if ?$/<muloper> {
      for 0 .. (+$/<muloper> - 1) -> $index {
	my $oper = ~$/<muloper>[$index];
	if $oper ~~ '*' {
	  $value *= $/<term>[$index + 1].ast<value>;
	} elsif $oper ~~ '/' {
	  $value /= $/<term>[$index + 1].ast<value>;
	} elsif $oper ~~ '%' {
	  $value %= $/<term>[$index + 1].ast<value>;
	} elsif $oper ~~ '<<' {
	  $value +<= $/<term>[$index + 1].ast<value>;
	} elsif $oper ~~ '>>' {
	  $value +>= $/<term>[$index + 1].ast<value>;
	} else {
	  error_listing "Illegal operator";
	}
        $def &= $/<term>[$index + 1].ast<def>
      }
    }
    make mkexp($value, $def);
  }
  method string:sym<singlequote>($/) { make ~$/[0]; }
  method stringexpression($/) { make ~$/<string>.ast; }
  method plusminus($/) { make $/ eq '-' ?? -1 !! 1; }

  method bit($/) { ##### should be avr specific
    my $val = $/<expression>.ast;
    if 0 <= $val <= 7 {
      make $val;
    } else {
     error_listing '*** Bit number out of range';
     make 0;
    }
  }

# AVR specific methods

  method avr_reg($/) {
    my  $reg = $/[0];
    if $/[1].defined {
      my $offset = $/[1];
      $reg += $offset;
    }
    if ! (0 <= $reg <= 31) {
      error_listing '*** Registers must be in range r0 to r31';
      $reg = 0;
    }
    make $reg;
  }
  method avr_regpair($/) {
    my $r1 = $/[0];
    my $r2 = $/[1];
    error_listing ('*** Illegal register pair') unless ($r1 == $r2 + 1) && ($r1 +& 1);
    make $r2;
  }
  method instruction:sym<avr_rr>($/) {
    my $opcode = %instructions<avr><rr><hash>{~$/<mnemonic>};
    my $r1 = +$/<avr_reg>[0].ast;
    my $r2 = +$/<avr_reg>[1].ast;
    $opcode +|= ($r1 +< 4) +& 0x1f0;
    $opcode +|=  $r2       +& 0x0f;
    $opcode +|= ($r2 +< 5) +& 0x200;
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<avr_ww1>($/) {
    my $opcode = %instructions<avr><ww><hash>{~$/<mnemonic>};
    my $r1 = +$/<regpair>[0].ast;
    my $r2 = +$/<regpair>[1].ast;
    $opcode +|= ($r1 +< 3) +& 0x00f0;
    $opcode +|= ($r2 +> 1) +& 0x000f;
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<avr_ww2>($/) {
    my $opcode = %instructions<avr><ww><hash>{~$/<mnemonic>};
    my $r1 = +$/<avr_reg>[0].ast;
    my $r2 = +$/<avr_reg>[1].ast;
    $opcode +|= ($r1 +< 3) +& 0x00f0;
    $opcode +|= ($r2 +> 1) +& 0x000f;
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<avr_rr3>($/) {
    my $opcode = %instructions<avr><rr3><hash>{~$/<mnemonic>};
    my $r1 = +$/<avr_reg>[0].ast;
    my $r2 = +$/<avr_reg>[1].ast;
    if ( (16 <= $r1 < 24) && (16 <= $r2 < 24) ) {
      $opcode +|= ($r1 +< 4) +& 0x0070;
      $opcode +|=  $r2       +& 0x0007;
    } else {
      error_listing '*** Registers must be in range 16 to 23';
    }
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<avr_rr4>($/) {
    my $opcode = %instructions<avr><rr4><hash>{~$/<mnemonic>};
    my $r1 = +$/<avr_reg>[0].ast;
    my $r2 = +$/<avr_reg>[1].ast;
    if ( (16 <= $r1 < 32) && (16 <= $r2 < 32) ) {
      $opcode +|= ($r1 +< 4) +& 0x00f0;
      $opcode +|=  $r2       +& 0x000f;
    } else {
      error_listing '*** Registers must be in range 16 to 31';
    }
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<avr_r2>($/) {
    my $opcode = %instructions<avr><r2><hash>{~$/<mnemonic>};
    my $r1 = +$/<avr_reg>.ast;
    $opcode +|= ($r1 +< 4) +& 0x1f0;
    $opcode +|=  $r1       +& 0x0f;
    $opcode +|= ($r1 +< 5) +& 0x200;
    make( ($opcode,) ); # don't remove the comma!
  }
  method instruction:sym<avr_iw>($/) {
    my $opcode = %instructions<avr><iw><hash>{~$/<mnemonic>};
    my $reg = $/<regpair>.ast;
    my $val = $/<expression>.ast<value>;
    if ($reg < 24) || ($reg +& 1) {
      error_listing('*** Register must be r25:r24, r27:r26, r29:r28 or r31:r30');
      $reg = 24;
    }
    $opcode +|= ($reg +< 1) +& 0x0030;
    $opcode +|=  $val       +& 0x000f;
    $opcode +|= ($val +< 2) +& 0x00c0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_iw2>($/) {
    my $opcode = %instructions<avr><iw><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>.ast<value>;
    if ($reg < 24) || ($reg +& 1) {
      error_listing('*** Register must be r24, r26, r28 or r30');
      $reg = 24;
    }
    $opcode +|= ($reg +< 1) +& 0x0030;
    $opcode +|=  $val       +& 0x000f;
    $opcode +|= ($val +< 2) +& 0x00c0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_ir>($/) {
    my $opcode = %instructions<avr><ir><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>.ast<value>;
    if $reg < 16 {
      error_listing('*** Register must be r16 - r31');
      $reg = 16;
    }
    $opcode +|= ($reg +< 4) +& 0x00f0;
    $opcode +|=  $val       +& 0x000f;
    $opcode +|= ($val +< 4) +& 0x0f00;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_i6r>($/) {
    my $opcode = %instructions<avr><i6r><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>.ast<value>;
    if 0 <= $val <= 63 {
      $opcode +|= ($reg +< 4) +& 0x01f0;
      $opcode +|=  $val       +& 0x000f;
      $opcode +|= ($val +< 4) +& 0x0f00;
    } else {
      error_listing '*** Location must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<avr_out>($/) {
    my $opcode = %instructions<avr><out><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>.ast<value>;
    if 0 <= $val <= 63 {
      $opcode +|= ($reg +< 4) +& 0x01f0;
      $opcode +|=  $val       +& 0x000f;
      $opcode +|= ($val +< 4) +& 0x0f00;
    } else {
      error_listing '*** Location must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<avr_irc>($/) {
    my $opcode = %instructions<avr><irc><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>.ast<value> +^ 0xff;
    if $reg < 16 {
      error_listing('*** Register must be r16 - r31');
      $reg = 16;
    }
    $opcode +|= ($reg +< 4) +& 0x00f0;
    $opcode +|=  $val       +& 0x000f;
    $opcode +|= ($val +< 4) +& 0x0f00;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_r>($/) {
    my $opcode = %instructions<avr><r><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
# TODO -- what was this for?
#    if ! %avr_instr_r_reg & (1 +< $reg) {
#      error_listing "Invalid use of register $reg";
#    }
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_inh>($/) {
    my $opcode = %instructions<avr><inh><hash>{~$/<mnemonic>};
    make ( ($opcode,) );
  }
  method instruction:sym<avr_sreg>($/) {
    my $opcode = %instructions<avr><sreg><hash>{~$/<mnemonic>};
    my $bit = $/<avr_bit>.ast;
    $opcode +|= ($bit +< 4) +& 0x0070;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_tbit>($/) {
    my $opcode = %instructions<avr><tbit><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $bit = $/<avr_bit>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    $opcode +|=  $bit       +& 0x0007;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_brb>($/) {
    my $opcode = %instructions<avr><brb><hash>{~$/<mnemonic>};
    my $bit = $/<avr_bit>.ast;
    my $target = $/<expression>.ast<value>;
    my $offset = $target - $pc - 1;
    error_listing "*** Branch out of range (from $pc to $target)" if $offset > 63 || $offset < -64;
    $opcode +|= ($offset +< 3) +& 0x03f0;
    $opcode +|=  $bit          +& 0x0007;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_branch>($/) {
    my $opcode = %instructions<avr><branch><hash>{~$/<mnemonic>};
    my $target = $/<expression>.ast<value>;
    my $offset = $target - $pc - 1;
    error_listing "*** Branch out of range (from $pc to $target)" if $offset > 63 || $offset < -64;
    $opcode +|= ($offset +< 3) +& 0x03f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_lbranch>($/) {
    my $opcode = %instructions<avr><lbranch><hash>{~$/<mnemonic>};
    my $target = $/<expression>.ast<value>;
    my $offset = $target - $pc - 1;
    error_listing "*** Branch out of range (from $pc to $target)" if $offset > 2047 || $offset < -2048;
    $opcode +|= $offset +& 0x0fff;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_long>($/) {
    my $opcode = %instructions<avr><long><hash>{~$/<mnemonic>};
    my $target = $/<expression>.ast<value>;
    $opcode +|= ($target +> 16) +& 0x0001;
    $opcode +|= ($target +> 13) +& 0x01f0;
    make ( ($opcode,($target +& 0xffff)) );
  }
  method instruction:sym<avr_lds>($/) {
# TODO: Handle 7-bit address variant
    my $opcode = %instructions<avr><lds><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $addr = $/<expression>.ast<value>;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,($addr +& 0xffff)) );
  }
  method instruction:sym<avr_sts>($/) {
# TODO: Handle 7-bit address variant
    my $opcode = %instructions<avr><sts><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $addr = $/<expression>.ast<value>;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,($addr +& 0xffff)) );
  }
  method instruction:sym<avr_bio>($/) {
    my $opcode = %instructions<avr><bio><hash>{~$/<mnemonic>};
    my $bit = $/<avr_bit>.ast;
    my $reg = $/<expression>.ast<value>;
    error_listing '*** I/O register must be in range 0 to 31' if $reg < 0 || $reg >= 32;
    $opcode +|=  $bit       +& 0x0007;
    $opcode +|= ($reg +< 3) +& 0x00f8;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_i4>($/) {
    my $opcode = %instructions<avr><i4><hash>{~$/<mnemonic>};
    my $round = $/<expression>.ast<value>;
    error_listing '*** Round must be in range 0 to 15' if $round < 0 || $round >= 16;
    $opcode +|= ($round +< 4) +& 0x00f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_rx>($/) {
    my $opcode = %instructions<avr><rx><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_xr>($/) {
    my $opcode = %instructions<avr><xr><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_rxplus>($/) {
    my $opcode = %instructions<avr><rxplus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_xrplus>($/) {
    my $opcode = %instructions<avr><xrplus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_rxminus>($/) {
    my $opcode = %instructions<avr><rxminus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_xrminus>($/) {
    my $opcode = %instructions<avr><xrminus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_ry>($/) {
    my $opcode = %instructions<avr><ry><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_yr>($/) {
    my $opcode = %instructions<avr><yr><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_ryplus>($/) {
    my $opcode = %instructions<avr><ryplus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_yrplus>($/) {
    my $opcode = %instructions<avr><yrplus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_ryminus>($/) {
    my $opcode = %instructions<avr><ryminus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_yrminus>($/) {
    my $opcode = %instructions<avr><yrminus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_ryq>($/) {
    my $opcode = %instructions<avr><ryq><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>.ast<value>;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    if 0 <= $val <= 63 {
      $opcode +|=  $val       +& 0x0007;
      $opcode +|= ($val +< 7) +& 0x0c00;
      $opcode +|= ($val +< 8) +& 0x1000;
    } else {
      error_listing '*** Offset must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<avr_yrq>($/) {
    my $opcode = %instructions<avr><yrq><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>.ast<value>;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    if 0 <= $val <= 63 {
      $opcode +|=  $val       +& 0x0007;
      $opcode +|= ($val +< 7) +& 0x0c00;
      $opcode +|= ($val +< 8) +& 0x1000;
    } else {
      error_listing '*** Offset must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<avr_rz>($/) {
    my $opcode = %instructions<avr><rz><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_stzr>($/) {
    my $opcode = %instructions<avr><stzr><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_rzplus>($/) {
    my $opcode = %instructions<avr><rzplus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_zrplus>($/) {
    my $opcode = %instructions<avr><zrplus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_rzminus>($/) {
    my $opcode = %instructions<avr><rzminus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_zrminus>($/) {
    my $opcode = %instructions<avr><zrminus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_rzq>($/) {
    my $opcode = %instructions<avr><rzq><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>.ast<value>;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    if 0 <= $val <= 63 {
      $opcode +|=  $val       +& 0x0007;
      $opcode +|= ($val +< 7) +& 0x0c00;
      $opcode +|= ($val +< 8) +& 0x1000;
    } else {
      error_listing '*** Offset must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<avr_zrq>($/) {
    my $opcode = %instructions<avr><zrq><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    my $val = $/<expression>.ast<value>;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    if 0 <= $val <= 63 {
      $opcode +|=  $val       +& 0x0007;
      $opcode +|= ($val +< 7) +& 0x0c00;
      $opcode +|= ($val +< 8) +& 0x1000;
    } else {
      error_listing '*** Offset must be 0 to 63';
    }
    make ( ($opcode,) );
  }
  method instruction:sym<avr_z>($/) {
    my $opcode = %instructions<avr><z><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_zr>($/) {
    my $opcode = %instructions<avr><zr><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_zplus>($/) {
    my $opcode = %instructions<avr><zplus><hash>{~$/<mnemonic>};
    my $reg = $/<avr_reg>.ast;
    $opcode +|= ($reg +< 4) +& 0x01f0;
    make ( ($opcode,) );
  }
  method instruction:sym<avr_noz>($/) {
    my $opcode = %instructions<avr><noz><hash>{~$/<mnemonic>};
    make ( ($opcode,) );
  }

# PIC-specific methods

  method pic18_f($/) {
    my  $reg = +$/;
    if ! (0 <= $reg <= 255) {
      error_listing '*** Registers must be in range 0 to 255';
      $reg = 0;
    }
    make $reg;
  }
  method pic18_d($/) {
    my  $reg = +$/;
    if ! (0 <= $reg <= 1) {
      error_listing '*** D must be 0 or 1';
      $reg = 0;
    }
    make $reg;
  }
  method pic18_a($/) {
    my  $reg = +$/;
    if ! (0 <= $reg <= 1) {
      error_listing '*** A must be 0 or 1';
      $reg = 0;
    }
    make $reg;
  }
  method pic18_bit($/) {
    my  $reg = +$/;
    if ! (0 <= $reg <= 7) {
      error_listing '*** bit number must be between 0 and 7';
      $reg = 0;
    }
    make $reg;
  }
  method instruction:sym<pic18_bytefda>($/) {
    my $opcode = %instructions<pic><bytefda><hash>{~$/<mnemonic>};
    my $f = $/<pic18_f>.ast;
    my $d = $/<pic18_d>.ast;
    my $a = $/<pic18_a>.ast;
    $opcode +|= $f;
    $opcode +|= $a +< 8;
    $opcode +|= $d +< 9;
    make ( ($opcode,) );
  }
  method instruction:sym<pic18_bytefa>($/) {
    my $opcode = %instructions<pic><bytefa><hash>{~$/<mnemonic>};
    my $f = $/<pic18_f>.ast;
    my $a = $/<pic18_a>.ast;
    $opcode +|= $f;
    $opcode +|= $a +< 8;
    make ( ($opcode,) );
  }
  method instruction:sym<pic18_byteff>($/) {
    my $opcode = %instructions<pic><byteff><hash>{~$/<mnemonic>};
    my $fs = $/<expression>[0].ast<value> +& 0x0fff;
    my $fd = $/<expression>[1].ast<value> +& 0x0fff;
    $opcode +|= $fs;
    make ( ($opcode, 0xf000 +| $fd) );
  }
  method instruction:sym<pic18_bitm>($/) {
    my $opcode = %instructions<pic><bit><hash>{~$/<mnemonic>};
    my $f = $/<pic18_f>.ast;
    my $b = $/<pic18_bit>.ast;
    my $a = $/<pic18_a>.ast;
    $opcode +|= $f;
    $opcode +|= $a +< 8;
    $opcode +|= $b +< 9;
    make ( ($opcode,) );
  }
  method instruction:sym<pic18_inh>($/) {
    my $opcode = %instructions<pic><inh><hash>{~$/<mnemonic>};
    make ( ($opcode,) );
  }
  method instruction:sym<pic18_branch>($/) {
    my $opcode = %instructions<pic><branch><hash>{~$/<mnemonic>};
    my $target = $/<expression>.ast<value>;
    my $offset = $target - $pc - 1;
    if ($offset < -128 || $offset > 127) {
    }
    $offset +&= 0xff;
    $opcode +|= $offset;
    make ( ($opcode,) );
  }
  method instruction:sym<pic18_lbranch>($/) {
    my $opcode = %instructions<pic><lbranch><hash>{~$/<mnemonic>};
    my $target = $/<expression>.ast<value>;
    my $offset = $target - $pc - 1;
    if ($offset < -1024 || $offset > 1023) {
    }
    $offset +&= 0x3ff;
    $opcode +|= $offset;
    make ( ($opcode,) );
  }
  method instruction:sym<pic18_call>($/) {
    my $opcode = %instructions<pic><call><hash>{~$/<mnemonic>};
    my $target = $/<expression>[0].ast<value>;
    $target +&= 0x0fffff;
    $opcode +|= $target +& 0x0fff;
    $opcode +|= 0x0100 if defined $/<expression>[1] && $/<expression>[1].ast<value> != 0;
    make ( ($opcode, 0xf000 + ($target +> 12)) );
  }
  method instruction:sym<pic18_ret>($/) {
    my $opcode = %instructions<pic><ret><hash>{~$/<mnemonic>};
    $opcode +|= 0x0001 if defined $/<expression> && $/<expression>.ast<value> != 0;
    make ( ($opcode,) );
  }
  method instruction:sym<pic18_lit>($/) {
    my $opcode = %instructions<pic><lit><hash>{~$/<mnemonic>};
    my $imm = $/<expression>.ast<value>;
    $imm +&= 0xff;
    make ( ($opcode +| $imm,) );
  }
  method instruction:sym<pic18_bsr>($/) {
    my $opcode = %instructions<pic><bsr><hash>{~$/<mnemonic>};
    my $imm = $/<expression>.ast<value>;
    $imm +&= 0x0f;
    make ( ($opcode +| $imm,) );
  }
  method instruction:sym<pic18_tblrd>($/) {
    my $opcode = %instructions<pic><tblrd><hash>{~$/<mnemonic>};
    my $type = ~$/[0];
    $opcode +|= 0x0001 if $type eq '*+';
    $opcode +|= 0x0002 if $type eq '*-';
    $opcode +|= 0x0003 if $type eq '+*';
    make ( ($opcode,) );
  }

# mc6809-specific methods 
  method mc6809_acc($/) {
    my  $acc = ~$/;
    make $acc eq 'a' ?? 0 !! 1;
  }
  method mc6809_reg16($/) {
    my  $acc = ~$/;
    my %mc6809_reg16 = ('x' => 0, 'y' => 1, 'u' => 2, 's' => 3);
    make %mc6809_reg16{$acc};
  }
  method mc6809_anyreg($/) {
    my $reg = ~$/;
    my %mc6809_anyreg = ('d' => 0, 'x' => 1, 'y' => 2, 'u' => 3, 's' => 4, 'pc' => 5, 'a' => 8, 'b' => 9, 'cc' => 10, 'dp' => 11);
    make %mc6809_anyreg{$reg};
  }
  method mc6809_idx:sym<predec>($/) {
    my $reg = $/<mc6809_reg16>.ast;
    my $postinc = ~$/[0].chars;
    my $postbyte = 0x84;
    $postbyte = 0x82 if $postinc == 1;
    $postbyte = 0x83 if $postinc == 2;
    make ( ($postbyte +| ($reg +< 5), ));
  }
  method mc6809_idx:sym<postinc>($/) {
    my $reg = $/<mc6809_reg16>.ast;
    my $postinc = ~$/[0].chars;
    my $postbyte = 0x84;
    $postbyte = 0x80 if $postinc == 1;
    $postbyte = 0x81 if $postinc == 2;
    make ( ($postbyte +| ($reg +< 5), ));
  }
  method mc6809_idx:sym<pcrel>($/) {
    my $target = $/<expression>.ast<value>;
    my $def    = $/<expression>.ast<def>;
    my $offset = $target - $pc; # fix for instruction length
    # assume 16-bit offset for now
    make ( (0x8d, $offset +> 8, $offset) );
  }
  method mc6809_idx:sym<off>($/) {
    my $def = $/<expression>.ast<def>;
    my $value = $/<expression>.ast<value>;
    my $reg = $/<mc6809_reg16>.ast;
    my $made = 0;
    if $def {
      if $value == 0 {
        make ( (0x84 +| $reg +< 5, ));
        $made = 1;
      } elsif -16 <= $value <= 15 {
        make ( (0x00 +| ($reg +< 5) +| $value +& 0x1f, ));
        $made = 1;
      } elsif -128 <= $value <= 127 {
        my $postbyte = 0x88;
        $postbyte +|= $reg +< 5;
        make ( ( $postbyte, $value ) );
        $made = 1;
      }
    } 
    if ! $made {
      make ( (0x89 +| ($reg +< 5), ($value +> 8), ($value +& 0xff)));
    }
  }
  method instruction:sym<mc6809_inh>($/) {
    my $opcode = %instructions<mc6809><inh><hash>{~$/<mnemonic>};
    if ($opcode > 0xff) {
      make ( ($opcode +> 8, $opcode +& 0xff) );
    } else {
      make ( ($opcode,) );
    }
  }
  method instruction:sym<mc6809_imm8>($/) {
    my $opcode = %instructions<mc6809><imm8><hash>{~$/<mnemonic>};
    my $imm = +$/<expression>.ast<value> +& 0xff;
    if ($opcode > 0xff) {
      make ( ($opcode +> 8, $opcode +& 0xff, $imm) );
    } else {
      make ( ($opcode, $imm) );
    }
  }
  method instruction:sym<mc6809_imm16>($/) {
    my $opcode = %instructions<mc6809><imm16><hash>{~$/<mnemonic>};
    my $imm = +$/<expression>.ast<value> +& 0xffff;
    if ($opcode > 0xff) {
      make ( ($opcode +> 8, $opcode +& 0xff, $imm +> 8, $imm +& 0xff) );
    } else {
      make ( ($opcode, $imm +> 8, $imm +& 0xff) );
    }
  }
  method instruction:sym<mc6809_br>($/) {
    my $opcode = %instructions<mc6809><br><hash>{~$/<mnemonic>};
    my $imm = +$/<expression>.ast<value> +& 0xffff;
    my $offset = $imm - ($pc + 2);
    if ($opcode > 0xff) {
      --$offset;
      make ( ($opcode +> 8, $opcode +& 0xff, $offset +& 0xff) );
    } else {
      make ( ($opcode, $offset +& 0xff) );
    }
  }
  method instruction:sym<mc6809_lbr>($/) {
    my $opcode = %instructions<mc6809><lbr><hash>{~$/<mnemonic>};
    my $imm = +$/<expression>.ast<value> +& 0xffff;
    my $offset = $imm - ($pc + 2);
    if ($opcode > 0xff) {
      --$offset;
      make ( ($opcode +> 8, $opcode +& 0xff, ($offset +> 8) +& 0xff, $offset +& 0xff) );
    } else {
      make ( ($opcode, ($offset +> 8) +& 0xff, $offset +& 0xff) );
    }
  }
  method instruction:sym<mc6809_ext>($/) {
    my $opcode = %instructions<mc6809><die><hash>{~$/<mnemonic>};
    my $imm = $/<expression>.ast<value> +& 0xffff;
    my $def = $/<expression>.ast<def>;
    if $def && ($imm +> 8) == %param<dp> {
	# use direct addressing
      $opcode +|= 0x10; # direct addressing mode
      $opcode +&= 0x8f if $opcode +& 0xf0 == 0x40; # ugh -- so much for orthogonality
      my $imm = +$/<expression>.ast<value> +& 0xff;
      if ($opcode > 0xff) {
        make ( ($opcode +> 8, $opcode +& 0xff, $imm) );
      } else {
        make ( ($opcode, $imm) );
      }
    } else {
      $opcode +|= 0x30; # extended addressing mode
      if ($opcode > 0xff) {
        make ( ($opcode +> 8, $opcode +& 0xff, $imm +> 8, $imm +& 0xff) );
      } else {
        make ( ($opcode, $imm +> 8, $imm +& 0xff) );
      }
    }
  }
  method instruction:sym<mc6809_dir>($/) {
    my $opcode = %instructions<mc6809><die><hash>{~$/<mnemonic>};
    $opcode +|= 0x10; # direct addressing mode
    $opcode +&= 0x8f if $opcode +& 0xf0 == 0x40; # ugh -- so much for orthogonality
    my $imm = +$/<expression>.ast<value> +& 0xff;
    if ($opcode > 0xff) {
      make ( ($opcode +> 8, $opcode +& 0xff, $imm) );
    } else {
      make ( ($opcode, $imm) );
    }
  }
  method instruction:sym<mc6809_ind1>($/) {
    my $opcode = %instructions<mc6809><die><hash>{~$/<mnemonic>};
    $opcode +|= 0x20; # indexed addressing mode
    my @postbytes = $/<mc6809_idx>.ast;
    if ($opcode > 0xff) {
      make ( ($opcode +> 8, $opcode +& 0xff, @postbytes) );
    } else {
      make ( ($opcode, @postbytes) );
    }
  }
  method instruction:sym<mc6809_ind2>($/) {
    my $opcode = %instructions<mc6809><die><hash>{~$/<mnemonic>};
    $opcode +|= 0x20; # indexed addressing mode
    my @postbytes = $/<mc6809_idx>.ast;
    @postbytes[0] +|= 0x10; # set indirect bit -- TODO fix 5 bit offsets
    if ($opcode > 0xff) {
      make ( ($opcode +> 8, $opcode +& 0xff, @postbytes) );
    } else {
      make ( ($opcode, @postbytes) );
    }
  }
  method instruction:sym<mc6809_ind3>($/) {
    my $opcode = %instructions<mc6809><die><hash>{~$/<mnemonic>};
    $opcode +|= 0x20; # indexed addressing mode
    if ($opcode > 0xff) {
      make ( ($opcode +> 8, $opcode +& 0xff, 0x9f, +$/<expression>.ast<value> +> 8, +$/<expression>.ast<value> +& 0xff) );
    } else {
      make ( ($opcode, 0x9f, +$/<expression>.ast<value> +> 8, +$/<expression>.ast<value> +& 0xff) );
    }
  }
  method instruction:sym<mc6809_tfr>($/) {
    my $opcode = %instructions<mc6809><tfr><hash>{~$/<mnemonic>};
    my $postbyte = ($/<mc6809_anyreg>[0].ast +< 4) +| $/<mc6809_anyreg>[1].ast;
    make ( ($opcode, $postbyte) );
  }
  method instruction:sym<mc6809_psh>($/) {
    my $opcode = %instructions<mc6809><psh><hash>{~$/<mnemonic>};
    my $postbyte = 0;
    for @($/<mc6809_anyreg>) -> $reg {
      if $reg eq 'd' {
        if $postbyte +& 0x06 {
           error_listing "*** Register d conflicts with previous register specification";
        }
        $postbyte +|= 0x06;
      }
      if $reg eq 'x' {
        if $postbyte +& 0x10 {
           error_listing "*** Register x conflicts with previous register specification";
        }
        $postbyte +|= 0x10;
      }
      if $reg eq 'y' {
        if $postbyte +& 0x20 {
           error_listing "*** Register y conflicts with previous register specification";
        }
        $postbyte +|= 0x20;
      }
      if $reg eq 'u' | 's' {
        if $postbyte +& 0x40 {
           error_listing "*** Register u/s conflicts with previous register specification";
        }
        $postbyte +|= 0x40;
      }
      if $reg eq 'pc' {
        if $postbyte +& 0x80 {
           error_listing "*** Register pc conflicts with previous register specification";
        }
        $postbyte +|= 0x80;
      }
      if $reg eq 'a' {
        if $postbyte +& 0x02 {
           error_listing "*** Register a conflicts with previous register specification";
        }
        $postbyte +|= 0x02;
      }
      if $reg eq 'b' {
        if $postbyte +& 0x04 {
           error_listing "*** Register b conflicts with previous register specification";
        }
        $postbyte +|= 0x04;
      }
      if $reg eq 'cc' {
        if $postbyte +& 0x01 {
           error_listing "*** Register cc conflicts with previous register specification";
        }
        $postbyte +|= 0x01;
      }
      if $reg eq 'dp' {
        if $postbyte +& 0x08 {
           error_listing "*** Register dp conflicts with previous register specification";
        }
        $postbyte +|= 0x08;
      }
    }
    make ( ($opcode, $postbyte) );
  }

# ARM specific methods

  method arm_reg($/) {
    my $reg = +$/[0];
    if $/[1].defined {
      $reg += $/[1];
    }
    if ! (0 <= $reg <= 15) {
      error_listing '*** Registers must be in range r0 to r15';
      $reg = 0;
    }
    make $reg;
  }
  method arm_cond($/) {
    my %arm_cond = ('eq' => 0, 'ne' => 1, 'cs' => 2, 'cc' => 3, 'mi' => 4, 'pl' => 5, 'vs' => 6, 'vc' => 7, 'hi' => 8, 'ls' => 9, 'ge' => 10, 'lt' => 11, 'gt' => 12, 'le' => 13, 'al' => 14, '' => 14);
    my $cond = 14; # default to "always"
    $cond = %arm_cond{~$/} if ~$/.defined;
    make ($cond +<= 28); # shift to where the instruction will use it
  }
  method arm_setcond($/) {
    my $setcond = (~$/ eq 's') ?? 0x01 !! 0x00;
    make ($setcond);
  }
  method arm_byte($/) {
    my $byte    = (~$/ eq 'b') ?? 0x01 !! 0x00;
    make ($byte);
  }
  method arm_sbh($/) {
    my %arm_sbh = ('h' => 0xb0, 'sb' => 0xd0, 'sh' => 0xf0, '' => 0xb0);
    make (%arm_sbh{~$/});
  }
  method instruction:sym<arm_inh>($/) {
    my $opcode = %instructions<arm><inh><hash>{~$/<mnemonic>};
    my $cond = $/<arm_cond>.ast;
    $opcode +|= $cond;
    make ( ($opcode,) );
  }
  method instruction:sym<arm_mul>($/) {
    my $opcode = %instructions<arm><mul><hash>{~$/<mnemonic>};
    $opcode +|= $/<arm_cond>.ast;
    $opcode +|= $/<arm_setcond>.ast +< 20;
    $opcode +|= $/<arm_reg>[0].ast +< 16;
    $opcode +|= $/<arm_reg>[1].ast;
    $opcode +|= $/<arm_reg>[2].ast +< 8;
    make ( ($opcode,) );
  }
  method instruction:sym<arm_mla>($/) {
    my $opcode = %instructions<arm><mla><hash>{~$/<mnemonic>};
    $opcode +|= $/<arm_cond>.ast;
    $opcode +|= $/<arm_setcond>.ast +< 20;
    $opcode +|= $/<arm_reg>[0].ast +< 16;
    $opcode +|= $/<arm_reg>[1].ast;
    $opcode +|= $/<arm_reg>[2].ast +< 8;
    $opcode +|= $/<arm_reg>[3].ast +< 12;
    make ( ($opcode,) );
  }
  method instruction:sym<arm_mull>($/) {
    my $opcode = %instructions<arm><mull><hash>{~$/<mnemonic>};
# TODO: check for valid register combinations
    $opcode +|= $/<arm_cond>.ast;
    $opcode +|= $/<arm_setcond>.ast +< 20;;
    $opcode +|= $/<arm_reg>[0].ast +< 12;
    $opcode +|= $/<arm_reg>[1].ast +< 16;
    $opcode +|= $/<arm_reg>[2].ast;
    $opcode +|= $/<arm_reg>[3].ast +< 8;
    make ( ($opcode,) );
  }
  method instruction:sym<arm_sds>($/) {
    my $opcode = %instructions<arm><sds><hash>{~$/<mnemonic>};
    $opcode +|= $/<arm_cond>.ast;
    $opcode +|= $/<arm_byte>.ast +< 22;
    $opcode +|= $/<arm_reg>[0].ast +< 12;
    $opcode +|= $/<arm_reg>[1].ast;
    $opcode +|= $/<arm_reg>[2].ast +< 16;
    make ( ($opcode,) );
  }
  method instruction:sym<arm_brx>($/) {
    my $opcode = %instructions<arm><brx><hash>{~$/<mnemonic>};
    $opcode +|= $/<arm_cond>.ast;
    $opcode +|= $/<arm_reg>.ast;
    make ( ($opcode,) );
  }
  method arm_hdtaddr:sym<expr>($/) {
    my $offset = $/<expression>.ast - $pc - 8;
# TODO Check for offset more than 8 bits either direction
    if ($offset < 0) {
      $offset = -$offset;
      make (0x01cf0090 +| (($offset +< 4) +& 0x0f00) +| ($offset +& 0x000f));
    } else {
      make (0x014f0090 +| (($offset +< 4) +& 0x0f00) +| ($offset +& 0x000f));
    }
  }
  method arm_hdtaddr:sym<reg>($/) {
    make (0x01400090 +| $/<arm_reg>.ast +< 16;);
  }
  method arm_hdtaddr:sym<preimm>($/) {
    my $offset = $/<expression>.ast;
# TODO Check for offset more than 8 bits either direction
    my $postbyte = 0x01400090;
    if ($offset < 0) {
      $offset = -$offset;
      $postbyte +|= 0x00800000;
    }
    $postbyte +|= $/<arm_reg>.ast +< 16;
    make ($postbyte +| (($offset +< 4) +& 0x0f00) +| ($offset +& 0x000f));
  }
  method arm_hdtaddr:sym<preind>($/) {
    my $postbyte = 0x01000090;
    if ($/<plusminus>.ast > 0) {
      $postbyte +|= 0x00800000;
    }
    $postbyte +|= 1 +< 21 if $/[0] eq '!';
    $postbyte +|= $/<arm_reg>[0].ast +< 16;
    $postbyte +|= $/<arm_reg>[1].ast;
    make ($postbyte);
  }
  method arm_hdtaddr:sym<postimm>($/) {
    my $offset = $/<expression>.ast;
# TODO Check for offset more than 8 bits either direction
    my $postbyte = 0x01400090;
    if ($offset < 0) {
      $offset = -$offset;
      $postbyte +|= 0x00800000;
    }
    $postbyte +|= $/<arm_reg>.ast +< 16;
    make ($postbyte +| (($offset +< 4) +& 0x0f00) +| ($offset +& 0x000f));
  }
  method arm_hdtaddr:sym<postind>($/) {
    my $postbyte = 0x00000090;
    if ($/<plusminus>.ast > 0) {
      $postbyte +|= 0x00800000;
    }
    $postbyte +|= $/<arm_reg>[0].ast +< 16;
    $postbyte +|= $/<arm_reg>[1].ast;
    make ($postbyte);
  }
  method instruction:sym<arm_hdt>($/) {
    my $opcode = %instructions<arm><hdt><hash>{~$/<mnemonic>};
    $opcode +|= $/<arm_cond>.ast;
    $opcode +|= $/<arm_hdtaddr>.ast;
    $opcode +|= $/<arm_sbh>.ast;
    make ( ($opcode,) );
  }

}

# Input routines

my $input_line = sub { return Str; };
my $line_number = 0;

sub
include_file(Str $filename) {
  my $HANDLE = open $filename, :r;
  my $old_input_line = $input_line;
  my $old_line_number = $line_number;
  $line_number = 0;
  $input_line = sub {
    my $line = $HANDLE.get;
    if ! $line.defined {
      $input_line = $old_input_line;
      $line_number = $old_line_number;
      if $input_line.defined {
	return $input_line();
      } else {
	return Str;
      }
    }
    ++$line_number;
    return $line;
  };
}

my %macro = ();
my $current_macro_def = '';
my $ifdepth = 0;
my $truedepth = 0;
my %define = ();

sub
expand_macro(Str $label, Str $opcode, Str $rest) {
  my $old_input_line = $input_line;
  my $old_line_number = $line_number;
  $line_number = 0;
  my $macro_name = $opcode;
  my $index = 0;
  my @args = $rest.comb(/
			<?after \"> <-[\"]>+ <?before \"> # stuff in quotes
			| \w+                                # or words
			/);
  $index = 0;
  $input_line = sub {
    my $line = %macro{$macro_name}[$index++];
    if ! $line.defined {
      $input_line = $old_input_line;
      $line_number = $old_line_number;
      if $input_line.defined {
	return $input_line();
      } else {
	return Str;
      }
    }
    # interpolate the arguments
#    say "Interpolating arguments ", @args.perl, " into $line\n";
    while ($line ~~ m/\@(<digit>)/) {
      my $value = @args[$/[0]];
      $line ~~ s/\@<digit>/{$value}/;
    }
    ++$line_number;
    return $line;
  };
}

sub
parse_line(Str $line) {
  my $tline = $line;
  my Str $label = '';
  my Str $opcode = '';
  my Str $rest = '';
  if $tline ~~ /^\S/ { # we have a label
        $tline ~~ s/^(\S+)//;
       $label = ~$0;
  } else {
    #say "no label";
  }
  $tline ~~ s/^\s+//;
  if $tline ~~ /^[\w|\.]/ {
    $tline ~~ s/^(\S+)//;
    $opcode = ~$0;
  }
  $tline ~~ s/^\s+//;
  $rest = $tline;
  my $orig_rest = $rest;
  if %macro{$opcode.lc}.defined {
    format_listing(-1, '', $label, $opcode, $rest);
    expand_macro($label, $opcode.lc, $rest);
    next;
  }
  $rest ~~ s:g/ <wb>(\w+)<wb> /{
				my $word = $0;
				if %define{$word}.defined {
				  %define{$word}
				} else {
				  $word
				}
			       }/;
  return ($label, $opcode, $orig_rest, $rest);
}

sub
get_next_line {
  loop {
    if ! $input_line.defined {
      return (Str, Str, Str, Str);
    }
    my Str $line = $input_line();
    if ! $line.defined {
      return (Str, Str, Str, Str);
    }
    if $current_macro_def {
      if $line ~~ m/^<ws>\.endm<wb>/ {
	$current_macro_def = '';
      } else {
	%macro{$current_macro_def}.push($line);
      }
      simple_listing($line);
      next;
    }
    if $line ~~ m/^<ws>?[<[\#;]>.*]?$/ { # comments
      simple_listing($line);
      next;
    }
    if $line ~~ m/^<ws>\.macro<ws>(\S+)/ {
      simple_listing($line);
      $current_macro_def = ~$/[0];
      %macro{$current_macro_def} = [];
      next;
    }
    if $line ~~ m/^<ws>\.include<ws>(\S+)/ {
      simple_listing($line);
      include_file(~$/[0]);
      next;
    }
    if $line ~~ m/^<ws>  \.if <ws> / {
      if $ifdepth == $truedepth {
	# only in this case do we care about the value of the expression
	my $expr = $line;
	$expr ~~ s/^<ws> '.if' <ws>//;
	my $m = Assembler.parse($expr,
				:actions(Assembler::Actions),
				:rule(<expression>));
	if ?+$m.ast<value> {
	  ++$truedepth;
	}
      }
      ++$ifdepth;
      next;
    }
    if $line ~~ m/^<ws>\.else<wb>/ {
      if $ifdepth == $truedepth {
	--$truedepth;
      } else {
	if $ifdepth == $truedepth + 1 {
	  ++$truedepth;
	}
      }
      next;
    }
    if $line ~~ m/^<ws>\.endif<wb>/ {
      --$ifdepth;
      if $ifdepth < $truedepth {
	$truedepth = $ifdepth;
      }
      next;
    }
    if ($truedepth == $ifdepth) {
      my ($label, $opcode, $orig_rest, $rest) = parse_line($line);
      return ($line, $label, $opcode, $orig_rest, $rest);
    }
    else {
        simple_listing $line;
    }
  }
}

# Output

my $suppress_output = 1;
my $nolist = 0;

# listing

sub simple_listing(Str $line) {
  return if $suppress_output; # some variables below don't exist on earlier passes
  return if $nolist;
  printf "%4d                 %s\n", $line_number, $line;
}

sub error_listing(Str $msg) {
  return if $suppress_output; # some variables below don't exist on earlier passes
  return if $nolist;
  printf "                    %s\n", $msg;
}

sub format_listing(Int $pc, Str $code, Str $label, Str $opcode, Str $rest) {
  return if $suppress_output; # some variables below don't exist on earlier passes
  return if $nolist;
  my $code_str = $code;
  if $code.chars > %param<codewidth> {
    $code_str = substr($code, 0, 9) ~ '>';
  }
  my $pcformat = '';
  my $pc_str;
  if $pc >= 0 {
    $pcformat = ' ' x %param<pcwidth>
      - +@memspace[0]<pcwidth> ~
	'%0'
	  ~ sprintf('%d.%dx ', +@memspace[0]<pcwidth>, +@memspace[0]<pcwidth>)
	    ~ @memspace[0]<label>;
    $pc_str = (($pc < 0) ?? (' ' x (%param<pcwidth> + 2)) !! sprintf($pcformat, $pc));
  } else {
    $pc_str = ' ' x (%param<pcwidth> + 2);
  }
  my $fmt = ' %4d %s %-' ~ %param<codewidth>+1 ~ 's %8s %8s %s' ~ "\n";
  printf $fmt, $line_number, $pc_str, $code_str, $label, $opcode, $rest;
}

# S1 output

my %bytes;

my $s1outaddr = -2; # don't use -1
my $s1outcount = 0;
my $s1outstring = '';
my $s1checksum = 0;
my $s1_header = '';

my Str $s1file = '';

# Code to handle S1 format output files

sub putword($addr, $word) {
  %bytes{$addr} = $word +& 0x00ff;
  %bytes{$addr+1} = ($word +> 8) +& 0x00ff;
}

sub hexbyte($byte) {
  my $nybble2 = (($byte     ) +& 0x0f) + 0x30;
  $nybble2 += 7 if $nybble2 >= 0x3a;
  my $nybble1 = (($byte +> 4) +& 0x0f) + 0x30;
  $nybble1 += 7 if $nybble1 >= 0x3a;
  my $c1 = $nybble1.chr;
  my $c2 = $nybble2.chr;
  my $string = $c1 ~ $c2;
  return $string;
}

sub put_bytes($header, $count, $string, $checksum) {
  print $header;
  print hexbyte($count);
  print $string;
  my $tchecksum = $checksum +& 0x0ff;
  print hexbyte($tchecksum);
  print "\n";
}

sub write_s1_record() {
  if ($s1outaddr >= 0) {
    $s1checksum += $s1outcount;
    put_bytes($s1_header, $s1outcount+1, $s1outstring, +^$s1checksum);
    $s1outaddr = -2;
    $s1outcount = 0;
  }
}

sub write_s1byte($addr, $byte) {
  my $value = $byte +& 0xff;
  if ($addr != ($s1outaddr + 1)) {
    write_s1_record();
  }
  if ($s1outcount == 0) {
    if ($addr < 0x10000) {
      $s1_header = 'S1';
      $s1outstring = hexbyte($addr +> 8) ~ hexbyte($addr);
      $s1checksum = ($addr +> 8) + $addr;
      $s1outcount = 2;
    } elsif ($addr < 0x1000000) {
      $s1_header = 'S2';
      $s1outstring = hexbyte($addr +> 16) ~ hexbyte($addr +> 8) ~ hexbyte($addr);
      $s1checksum = ($addr +> 16) + ($addr +> 8) + $addr;
      $s1outcount = 3;
    } else {
      $s1_header = 'S3';
      $s1outstring = hexbyte($addr +> 24) ~ hexbyte($addr +> 16) ~ hexbyte($addr +> 8) ~ hexbyte($addr);
      $s1checksum = ($addr +> 24) + ($addr +> 16) + ($addr +> 8) + $addr;
      $s1outcount = 4;
    }
  }
  $s1outstring ~= hexbyte($byte);
  $s1checksum += $byte;
  ++$s1outcount;
  $s1outaddr = $addr;
  if ($s1outcount >= 18) {
    write_s1_record();
  }
}

sub write_s1($file) {
  my $*OUT = open($file, :w);
  for sort {$^a <=> $^b}, %bytes.keys -> $addr {
    write_s1byte(+$addr, %bytes{$addr});
  }
  write_s1_record(); # flush any remaining buffer
  say "S9030000FC";
}

sub assign_symbol(Str $labelfield, $value, $pass) {
  my $label = $labelfield.lc;
  $label ~~ s/\:$//;
  if ($label ~~ /^(\d\d?)$/ ) {
    if ($pass == 1) {
      @local_symbol[$0] = [] unless @local_symbol[$0].defined;
      @local_symbol[$0].push($pc);
    }
    ++@local_pointer[$0];
  } else {
    %symbol{$label} = {} unless %symbol{$label}.defined;
    %symbol{$label}<value> = +$value;
    %symbol{$label}<memspace> = @memspace[0]<id>;
    %symbol{$label}<pass> = $pass;
  }
}

my %constantsize = '.db' => 1,
                   '.dw' => 2,
		   '.dl' => 4;

%directive<.byte> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing($pc, '', $label, $opcode, $rest);
  assign_symbol($label, +$pc, $pass) if $label; ++$pc;
};
%directive<.word> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing($pc, '', $label, $opcode, $rest);
  assign_symbol($label, +$pc, $pass) if $label;
  $pc += 2;
};
%directive<.long> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing($pc, '', $label, $opcode, $rest);
  assign_symbol($label, +$pc, $pass) if $label;
  $pc += 4;
};
%directive<.list> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing(-1, '', $label, $opcode, $rest);
  $nolist--;
  $nolist = 0 if $nolist < 0;
};
%directive<.nolist> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing(-1, '', $label, $opcode, $rest);
  ++$nolist;
};
%directive<.device> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing(-1, '', $label, $opcode, $rest);
};
%directive<.listmac> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  format_listing(-1, '', $label, $opcode, $rest);
};
%directive<.set> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  my $m = Assembler.parse($args,
			  :actions(Assembler::Actions),
			  :rule(<identifier>));
  my $symbol = ~$m[0];
  $args ~~ s/^<-[=]>* <ws>? '=' <ws>? //;
  $m = Assembler.parse($args,
		       :actions(Assembler::Actions),
		       :rule(<expression>));
  my $value = +$m.ast<value>;
  format_listing(-1, '', $label, $opcode, $rest);
  assign_symbol($symbol, +$m.ast, $pass);
};
%directive<.def> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  chomp $args;
  my $m = Assembler.parse($args,
			  :actions(Assembler::Actions),
			  :rule(<identifier>));
  my $symbol = ~$m[0];
  $args = $args.substr(+$m.to); # remove identifier
  $args ~~ s/ ^ <ws> \= <ws> //;
  $m = Assembler.parse($args,
		       :actions(Assembler::Actions),
		       :rule(<identifier>));
  my $value = ~$m[0];
  simple_listing ".def $symbol = $value";
  %define{$symbol} = $value;
};
%directive<.param> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  my $m = Assembler.parse($args,
			  :actions(Assembler::Actions),
			  :rule(<identifier>));
  my $param = ~$m[0];
  $args = $args.substr(+$m.to); # remove identifier
  $args ~~ s/ ^ <ws>? \= <ws>? //;
  $m = Assembler.parse($args,
		       :actions(Assembler::Actions),
		       :rule(<expression>));
  my $value = +$m.ast<value>;
  simple_listing ".param $param = $value";
  %param{$param} = $value;
};
%directive<.equ> = %directive<.set>;
%directive<.db> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $size = %constantsize{$opcode};
  my $format = sprintf("\%\%0\%dx", $size*2);
  my $args = $rest;
  assign_symbol($label, $pc, $pass) if $label;
  loop {
    my $m = Assembler.parse($args,
			    :actions(Assembler::Actions),
			    :rule(<expression>));
    if ?$m {
      my $value = $m.ast<value>;
      format_listing($pc, sprintf($format, +$value), $label, $opcode, $rest);
      putword($pc*2, $value); # FIX
      if ($size == 4) {
        putword($pc*2 + 2, $value +> 16);
      }
      $pc += $size div 2;
      $args = $args.substr(+$m.to);
      $m = $args ~~ m/ ',' /;
      last unless ?$m;
      $args = $args.substr(+$m.to); 
    } else {
      error_listing '*** unknown value';
      format_listing($pc, '', $label, $opcode, $rest);
      last;
    }
  }
};
%directive<.dw> = %directive<.db>;
%directive<.dl> = %directive<.db>;
%directive<.end> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  say ".end" unless $nolist;
};
%directive<.exit> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  simple_listing ".exit";
};
%directive<.org> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  say ".org" unless $nolist;
  my $m = Assembler.parse($rest,
			  :actions(Assembler::Actions),
			  :rule(<expression>));
  $pc = +$m.ast<value>;
};
%directive<.pushmem> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $m = Assembler.parse($rest,
			  :actions(Assembler::Actions),
			  :rule(<identifier>));
  my $arg = ~$m[0];
  if ! %memspace{$arg}.defined {
    %memspace{$arg} = {};
    %memspace{$arg}<pc> = 0.Int;
    %memspace{$arg}<id> = $arg;
  }
  @memspace.unshift(%memspace{$arg});
  $pc := @memspace[0]<pc>;
};
%directive<.popmem> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  shift @memspace;
  $pc := @memspace[0]<pc>;
};
%directive<.defmem> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  my $m = Assembler.parse($args,
			  :actions(Assembler::Actions),
			  :rule(<identifier>));
  my $symbol = ~$m[0];
  $args ~~ s/^<-[=]>* <ws>? '=' <ws>? //;
  $m = Assembler.parse($args,
		       :actions(Assembler::Actions),
		       :rule(<expression>));
  if ?$m {
    my $value = +$m.ast<value>;
    format_listing(-1, '', $label, $opcode, $rest);
    @memspace[0]{$symbol} = $value;
  } else {
    $m = Assembler.parse($args,
  		       :actions(Assembler::Actions),
  		       :rule(<stringexpression>));
    if ?$m {
      my $value = ~$m.ast;
      format_listing -1, '', $label, $opcode, $rest;
      @memspace[0]{$symbol} = $value;
    } else {
      simple_listing 'Unrecognised value field';
      format_listing -1, '', $label, $opcode, $rest;
    }
  }
};
%directive<.dump> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  my $args = $rest;
  my @args = $rest.split(',');
  for @args -> $arg {
    if $arg eq 'symbols' {
      print_symbols();
    }
  }
};
%directive<.isa> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  return unless $pass == 1;
  my $args = $rest;
  my $m = Assembler.parse($args,
                          :actions(Assembler::Actions),
                          :rule(<identifier>));
  if ?$m {
    $isa = ~$m[0];
  } else {
    say "Invalid format for .isa directive";
  }
}
# .instruction inh     clt    0x94d8
%directive<.instruction> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  return unless $pass == 1;
  my $args = $rest;
  my $m = Assembler.parse($args,
			  :actions(Assembler::Actions),
			  :rule(<identifier>));
  my $instr_type = ~$m[0];
  $args ~~ s/^ <.ws>? \S+ <.ws>? //;
  $m = Assembler.parse($args,
                       :actions(Assembler::Actions),
		       :rule(<identifier>));
  my $opc = ~$m[0];
  $args ~~ s/^ <.ws>? \S+ <.ws>? //;
  $m = Assembler.parse($args,
		       :actions(Assembler::Actions),
		       :rule(<expression>));
  my $value = +$m.ast<value>;
  format_listing(-1, '', $label, $opcode, $rest);
#say ".instruction: $isa $instr_type $opc $value";
  %instructions{$isa}{$instr_type}<hash>{$opc} = $value;
};
%directive<.assemble> = sub (Str $label, Str $opcode, Str $rest, Int $pass) {
  #say %instructions;
  for %instructions{$isa}.keys {
    my $arrayname = %instructions{$isa}{$_}<array>;
    eval "\@$arrayname = <%instructions{$isa}{$_}.keys>";
  }
}

sub assemble_instruction($label, $opcode, $orig_rest, $rest) {
  my $words = ();
  my $code = '';
  my $instruction_length = 0;
  if $opcode {
    my $m = Assembler.parse("$opcode $rest ",
			    :actions(Assembler::Actions),
			    :rule(<instruction>));
    if $m {
      $words = $m.ast;
      my $nybbles = ((@memspace[0]<width> + 3) / 4);
      my $format = '%0' ~ sprintf("%d.%dx ", $nybbles, $nybbles);
#say $words.perl;
      for ^+$words -> $index {
        $code ~= sprintf($format, $words[$index]);
	putword(($pc+$instruction_length)*2, $words[$index]);
	$instruction_length++;
      }
      $code ~~ s/ ' ' $//; # delete trailing space
    } else {
      error_listing "*** Unrecognised instruction format";
    }
  }
  format_listing($pc, $code, $label, $opcode, $orig_rest);
  $pc += $instruction_length;
}

my @files = ();

sub do_pass(Int $pass_number) {
  $suppress_output = ($pass_number == 2) ?? 0 !! 1;
  $suppress_output = 0;
  $ifdepth = 0;
  $truedepth = 0;
  $current_macro_def = '';
  setup_local_pointer();
# reset program counters
  for %memspace.keys -> $space {
    %memspace{$space}<pc> = 0;
  }
  @memspace = ({'pc' => 0.Int});
  $pc := @memspace[0]{'pc'};

# include the filenames in reverse order so the first gets opened first
# and then chains through to the second and so on
  for 0 .. +@files-1 ->$fileindex {
      include_file(@files[$fileindex]);
  }
  loop {
    my (Str $line, Str $label, Str $opcode, Str $orig_rest, Str $rest) = get_next_line();
    if ($line.defined) {
      if $opcode.defined {
        $rest = '' unless $rest.defined;
        $opcode = '' unless $opcode.defined;
        $opcode = $opcode.lc;
        if %directive{$opcode}.defined {
	  %directive{$opcode}($label, $opcode, $rest, $pass_number);
        } else {
	  assign_symbol($label, +$pc, $pass_number) if $label;
	  assemble_instruction($label, $opcode, $orig_rest, ~$rest);
        }
      } else {
        assign_symbol($label, $pc, $pass_number) if $label;
        format_listing($pc, '', $label, '', '');
      }
    } else {
      return(0);
    }
  }
}

sub print_symbols () {
  say "";
  say "Symbol Table:";
  say "=============";
  for (sort keys %symbol) -> $symbol {
    if $symbol ~~ /^_/ {
      # ignore symbols starting with _
    } else {
      my $pcformat = '';
      my $pc_str;
      my $pc = %symbol{$symbol}<value>;
      my $memspace = %symbol{$symbol}<memspace>;
      $pcformat = ' ' x %param<pcwidth>
	- +%memspace{$memspace}<pcwidth> ~
	  '%0'
	    ~ sprintf('%d.%dx ', +%memspace{$memspace}<pcwidth>, +%memspace{$memspace}<pcwidth>)
	      ~ %memspace{$memspace}<label>;
      $pc_str = sprintf($pcformat, $pc);
      say sprintf "%s %s", $pc_str, $symbol;
    }
  }
  say "";
  say "Definitions:";
  say "===========";
  for (sort keys %define) -> $symbol {
    if $symbol ~~ /^_/ {
      # ignore symbols starting with _
    } else {
      my $value = %symbol{$symbol};
      say sprintf "%s %s", $symbol, $value;
    }
  }
}

#######
#
# Here's where we put the machine specific stuff
#
#######

#######
#
# End of machine specific stuff
#
#######

# START HERE
for @*ARGS -> $arg {
  if $arg ~~ /^\-s/ {
    $s1file = ~$arg;
    $s1file ~~ s/^\-s//;
    next;
  }
  unshift @files, $arg; # last file specified will be first in list
}

{
#  my $*OUT = open '/dev/null', :w;
  do_pass(1+0);
}

do_pass(+2);

#say "Assembly completed!!!";
print_symbols();

if $s1file {
  write_s1($s1file);
}
